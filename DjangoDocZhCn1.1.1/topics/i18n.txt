.. _topics-i18n:

====================
国际化
====================

Django 在代码和和模板中都支持文本的的国际化。下面揭示了它是怎么工作的。

概述
========

国际化的使得一个 Web 应用能够在内容和功能上提供对多种语言的支持。

作为 Django 开发员，您只需要在代码和模板中添加最少量的钩子就能达到这个目的。
这些钩子被称作 **翻译字符串** 。它们告诉 Django ：“如果这些文字对应的翻译存在
，那么它们应该被翻译成为用户所使用的语言。”

Django 需要根据用户的语言偏好使用这些钩子翻译Web应用。

从本质上讲，Django做了两件事情：

    * 它让程序员和模板作者指定应用程序的哪些部分应该翻译。
    * 使用这些钩子根据用户的语言偏好翻译特定的部分。

如果在您的应用程序中不需要使用国际化
==================================================

Django的国际化钩子在默认情况下是启用的，这就意味会花费一些额外的开销。如果您不希望使用国际化，您可以花两秒钟在您的settings.py中设置
:setting:`USE_I18N = False <USE_I18N>`. 
如果 :setting:`USE_I18N` 被设置成 ``False`` ， Django会进行一些优化比如不载入国际化模块。

您还可以在 ``TEMPLATE_CONTEXT_PROCESSORS`` 中删除 
``'django.core.context_processors.i18n'`` 。

在应用程序中使用国际化只需三步
================================================

    1. 在您的Python代码和模板中嵌入待翻译的字符串。
    2. 把那些字符串翻译成您要支持的语言。
    3. 在您的Django settings文件中激活本地中间件。

.. admonition:: Behind the scenes

    Django的翻译机制使用Python中标准的 ``gettext`` 模块。

1. 怎样指定需要翻译的字符串
=====================================

翻译字符串指定“这些文字应该翻译。”这些翻译字符串可以出现在Python代码和模板中。您需要做的就是用翻译字符串标记那些需要翻译的内容；系统仅能翻译出它所知道的东西。

在Python代码中
--------------

标准翻译
~~~~~~~~~~~~~~~~~~~~

通过使用 ``ugettext()`` 指定一个翻译字符串。作为惯例，使用短别名 ``_``  来引入这个函数以节省键入时间。

.. note::
    Python的标准库 ``gettext`` 在全局命名空间中使用 ``_()`` 作为 ``gettext()`` 的别名。 在Django中我们不延续这个习惯有如下原因:

      1. 对于国际字符 (Unicode) 的支持, ``ugettext()`` 要比 ``gettext()`` 更有用。 有时对于一些特殊的文件您需要使用
         ``ugettext_lazy()`` 作为默认的翻译方法。 在全局命名空间中没有 ``_()`` ， 使得程序员需要考虑使用最合适的翻译函数。
         
      2. 下划线 (``_``) 在Python shell 和 doctest tests中表示 "之前的结果" 。载入一个全局的 ``_()`` 函数将会引起干扰。 明确的把 ``ugettext()`` 作为 ``_()`` 引入将避免这个问题。

.. highlightlang:: python

在这个例子中， 文字 ``"Welcome to my site."`` 被标记成为一个 翻译字符串::

    from django.utils.translation import ugettext as _

    def my_view(request):
        output = _("Welcome to my site.")
        return HttpResponse(output)

显然，您也可以不使用别名。 这个例子跟上面的例子是一样的::

    from django.utils.translation import ugettext

    def my_view(request):
        output = ugettext("Welcome to my site.")
        return HttpResponse(output)

翻译字符串对于计算出来的值同样有效。这个例子也跟前面两个例子一样::

    def my_view(request):
        words = ['Welcome', 'to', 'my', 'site.']
        output = _(' '.join(words))
        return HttpResponse(output)

翻译对变量也同样有效。同样，又一个相同的例子::

    def my_view(request):
        sentence = 'Welcome to my site.'
        output = _(sentence)
        return HttpResponse(output)

(以上两个例子中, 对于使用变量或计算值, 需要注意的一点是Django的待翻译字符串检测工具,
``django-admin.py makemessages``, 将不能找到这些字符串. 稍后,在
``makemessages`` 中会有更多讨论.)

传递给 ``_()`` 或 ``ugettext()`` 的字符可以使用由Python标准命名字符串插入句法指定的占位符。 例如::

    def my_view(request, m, d):
        output = _('Today is %(month)s, %(day)s.') % {'month': m, 'day': d}
        return HttpResponse(output)

这项技术使得译文将按照指定特定语言的顺序进行。例如，一段英文译文为 ``"Today is November, 26."`` ，
而西班牙语的译文将是 ``"Hoy es 26 de Noviembre."`` -- 占位符中 (月和日)的顺序被交换了 。

基于这个原因， 无论何时当您有多于一个单一参数时，您应当使用命名字符串插入 (例如，您需要用 ``%(day)s`` 或  ``%(key)d`` 来替代 ``%s`` 或 ``%d``) 。如果您使用位置插入的话，翻译动作将不能重新排序占位符文本。

标记字符串为不操作
~~~~~~~~~~~~~~~~~~~~~~~~

使用 ``django.utils.translation.ugettext_noop()`` 函数来标记一个不需要立即翻译的字符串。 这个串会稍后从变量翻译。

使用这种方法的环境是，有字符串必须以原始语言的形式存储（如储存在数据库中的字符串）而在最后需要被翻译出来（如显示给用户时）。

.. _lazy-translations:

惰性翻译
~~~~~~~~~~~~~~~~

使用 ``django.utils.translation.ugettext_lazy()`` 函数，使得其中的值只有在访问时才会被翻译，而不是在 
``ugettext_lazy()`` 被调用时翻译。

例如：要翻译一个模型的 ``help_text`` ，按以下进行::

    from django.utils.translation import ugettext_lazy

    class MyThing(models.Model):
        name = models.CharField(help_text=ugettext_lazy('This is the help text'))

在这个例子中， ``ugettext_lazy()`` 将字符串作为惰性参照存储，而不是实际翻译。 翻译工作将在字符串在字符串上下文中被用到时进行，比如在Django管理页面提交模板时。

在Python中，无论何处您要使用一个unicode 字符串(一个 ``unicode``) ，您都可以使用一个  ``ugettext_lazy()`` 调用的结果。 一个 ``ugettext_lazy()`` 对象并不知道如何把它自己转换成一个字节串。如果您尝试在一个需要字节串的地方使用它，事情将不会如您期待的那样。 同样，您也不能在一个字节串中使用一个 unicode 字符串。所以，这同常规的Python行为是一致的。 例如：::

    # This is fine: putting a unicode proxy into a unicode string.
    u"Hello %s" % ugettext_lazy("people")

    # This will not work, since you cannot insert a unicode object
    # into a bytestring (nor can you insert our unicode proxy there)
    "Hello %s" % ugettext_lazy("people")

如果您曾经见到到像 ``"hello
<django.utils.functional...>"`` 这样的输出，您就可能在一个字节串中插入了
``ugettext_lazy()`` 的结果。在您的代码中，那是一个漏洞。

如果觉得 ``ugettext_lazy`` 太过冗长， 可以用
``_`` (下划线)作为别名， 就像这样 ::

    from django.utils.translation import ugettext_lazy as _

    class MyThing(models.Model):
        name = models.CharField(help_text=_('This is the help text'))

在 :ref:`Django 模型 <topics-db-models>` 中总是无一例外的使用惰性翻译，
为了翻译，字段名和表名应该被标记。（否则的话，在管理界面中它们将不会被翻译） 这意味着在 ``Meta`` 类中显式地编写
``verbose_name`` 和 ``verbose_name_plural`` 选项，
而不是依赖于Django默认的
``verbose_name`` 和 ``verbose_name_plural`` 通过检查model的类名得到::

    from django.utils.translation import ugettext_lazy as _

    class MyThing(models.Model):
        name = models.CharField(_('name'), help_text=_('This is the help text'))
        class Meta:
            verbose_name = _('my thing')
            verbose_name_plural = _('mythings')

复数的处理
~~~~~~~~~~~~~

使用 ``django.utils.translation.ungettext()`` 来指定以复数形式表示的消息。

``ungettext`` 函数包括三个参数: 单数形式的翻译字符串，复数形式的翻译字符串，和对象的个数。

这个函数将非常有用，当您需要将您的Django应用本地化的语言存在多于两种的 `复数形式
<http://www.gnu.org/software/gettext/manual/gettext.html#Plural-forms>`_ ('object' for the singular and
'objects' for all the cases where ``count`` is different from zero, irrespective
of its value.)

例如::

    from django.utils.translation import ungettext
    def hello_world(request, count):
        page = ungettext('there is %(count)d object', 'there are %(count)d objects', count) % {
            'count': count,
        }
        return HttpResponse(page)

在这个例子中对象的数量通过 ``count`` 变量传递。

让我们来看一个略微复杂的例子::

    from django.utils.translation import ungettext

    count = Report.objects.count()
    if count == 1:
        name = Report._meta.verbose_name
    else:
        name = Report._meta.verbose_name_plural

    text = ungettext(
            'There is %(count)d %(name)s available.',
            'There are %(count)d %(name)s available.',
            count
    ) % {
        'count': count,
        'name': name
    }

在这里我们再利用本地化, 希望已经翻译了的句子中的其他部分始终基于
基数在起作用。

.. _pluralization-var-notes:

.. note::

    当使用这种方法时, 请确保您的每一个预测的变量使用的是单一名称。
    在下面的例子里演示了使用两个名字翻译字符串 ``name`` 的Python变量。
    这个例子将会出错 ::

        from django.utils.translation import ungettext
        from myapp.models import Report

        count = Report.objects.count()
        d = {
            'count': count,
            'name': Report._meta.verbose_name
            'plural_name': Report._meta.verbose_name_plural
        }
        text = ungettext(
                'There is %(count)d %(name)s available.',
                'There are %(count)d %(plural_name)s available.',
                count
        ) % d

您将会得到 ``a format specification for argument 'name', as in 'msgstr[0]', doesn't exist in 'msgid'`` error when running ``django-admin.py compilemessages`` or a ``KeyError`` Python 异常 。

在模板代码中
----------------

.. highlightlang:: html+django

在 :ref:`Django 模板 <topics-templates>` 中使用两种模板标签，且语法格式与Python代码有些许不同。 为了使得模板访问到标签，需要将  ``{% load i18n %}`` 放在模板最前面。

这个 ``{% trans %}`` 模板标记翻译一个常量字符串 (括以单或双引号) 或 可变内容::

    <title>{% trans "This is the title." %}</title>
    <title>{% trans myvar %}</title>

如果有 ``noop`` 选项，变量查询还是有效但翻译会跳过。当空缺内容要求将来再翻译时，这很有用。::

    <title>{% trans "myvar" noop %}</title>

在内部, 需翻译的内容由 ``ugettext`` 调用。

在一个带 ``{% trans%}`` 的字符串中，混进一个模板变量是不可能的。如果您的译文要求字符串带有变量(占位符placeholders)，请使用
``{% blocktrans %}``::

    {% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}

使用模板过滤器来翻译一个模板表达式，需要在翻译的这段文本中将表达式绑定到一个本地变量中：::

    {% blocktrans with value|filter as myvar %}
    This will have {{ myvar }} inside.
    {% endblocktrans %}

如果需要在 ``blocktrans`` 标签内绑定多个表达式，可以使用 ``and`` 来分割::

    {% blocktrans with book|title as book_t and author|title as author_t %}
    This is {{ book_t }} by {{ author_t }}
    {% endblocktrans %}

为了表示单复数相关的内容，需要在 ``{% blocktrans %}`` 和
``{% endblocktrans %}`` 之间使用 ``{% plural %}`` 标签来指定单复数形式，例如::

    {% blocktrans count list|length as counter %}
    There is only one {{ name }} object.
    {% plural %}
    There are {{ counter }} {{ name }} objects.
    {% endblocktrans %}

When you use the pluralization feature and bind additional values to local
variables apart from the counter value that selects the translated literal to be
used, have in mind that the ``blocktrans`` construct is internally converted
to an ``ungettext`` call. This means the same :ref:`notes regarding ungettext
variables <pluralization-var-notes>` apply.

每一个 ``RequestContext`` 可以访问三个指定翻译变量:

    * ``LANGUAGES`` 是一系列元组组成的列表，每个元组的第一个元素是语言代码，第二个元素是用该语言表示的语言名称。

    * ``LANGUAGE_CODE`` 作为字符串，是当前用户的优先语言。例如: ``en-us`` 。 (参见下面的 :ref:` how-django-discovers-language-preference ` )

    * ``LANGUAGE_BIDI`` 就是当前地域的说明。如果为真（True），它就是从右向左书写的语言，例如： 希伯来语，阿拉伯语。 如果为假（False），它就是从左到右书写的语言，如： 英语，法语，德语等。


如果您不使用 ``RequestContext`` 扩展， 您可以用3个标记到那些值：::

    {% get_current_language as LANGUAGE_CODE %}
    {% get_available_languages as LANGUAGES %}
    {% get_current_language_bidi as LANGUAGE_BIDI %}

这些标记亦需要 ``{% load i18n %}`` 。

翻译的钩子（hook）在任何接受常量字符串的模板块标签内也是可以使用的。 此时，使用 ``_()`` 表达式来指定翻译字符串，例如 ::

    {% some_special_tag _("Page not found") value|yesno:_("yes,no") %}

在这种情况下，标记和过滤器两个都会看到已经翻译的字符串，所有它们并不需要提防翻译操作。

.. note::
    在这个例子中，翻译结构将放过字符串
    ``"yes,no"`` ，而不是单独的字符串 ``"yes"`` and ``"no"`` 。翻译的字符串将需要包括逗号以便过滤器解析代码明白如何分割参数。 例如， 一个德语翻译器可能会翻译字符串 ``"yes,no"`` 为 ``"ja,nein"``
    (保持逗号原封不动)。

.. _Django templates: ../templates_python/

与惰性翻译对象一道工作
-------------------------------------

.. highlightlang:: python

在模型和公用函数中，使用 ``ugettext_lazy()`` 和 ``ungettext_lazy()`` 来标记字符串是很普遍的操作。 当您在您的代码中其它地方使用这些对象时，您应当确定您不会意外地转换它们成一个字符串，因为它们应被尽量晚地转换（以便正确的地域生效） 这需要使用及个帮助函数。

拼接字符串 : string_concat()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

标准Python 字符串拼接(``''.join([...])``)将不会工作包括惰性翻译对象的列表上。作为替代，您可以使用 
``django.utils.translation.string_concat()`` ，这个函数创建了一个惰性对象，其链接起它的内容 并且仅当结果被包括在一个字符串中是转换它们为字符串。例如:
::

    from django.utils.translation import string_concat
    ...
    name = ugettext_lazy(u'John Lennon')
    instrument = ugettext_lazy(u'guitar')
    result = string_concat([name, ': ', instrument])

``result`` will only be converted to
strings when ``result`` itself is used in a string (usually at template
rendering time).

allow_lazy() 修饰符 
~~~~~~~~~~~~~~~~~~~~~~~~~~

Django提供很多功能函数（如：取一个字符串作为他们的第一个参数并且对那个字符串做些什么）。(尤其在 ``django.utils`` 中) 这些函数被模板过滤器像在其他代码中一样直接使用。

如果您写您自己的类似函数并且与翻译打交道，当第一个参数是惰性翻译对象时，您会面临“做什么”的难题。因为您可能在视图之外使用这个函数（并且因此当前线程的本地设置将会不正确），所以您不想立即转换其为一个字符串。

象这种情况，请使用 ``django.utils.functional.allow_lazy()`` 修饰符。 它修改这个函数以便 假如第一个参数是一个惰性翻译， 这个函数的赋值会被延后直到它需要被转化为一个字符串为止。

例如 ::

    from django.utils.functional import allow_lazy

    def fancy_utility_function(s, ...):
        # Do some conversion on string 's'
        ...
    fancy_utility_function = allow_lazy(fancy_utility_function, unicode)

* ``allow_lazy()`` 装饰符 采用了另外的函数来装饰，以及一定量的，原始函数可以返回的特定类型的额外参数 (``*args``) 通常，在这里包括 ``unicode`` 就足够了并且确定您的函数将仅返回Unicode字符串。

使用这个修饰符意味着您能写您的函数并且假设输入是合适的字符串，然后在末尾添加对惰性翻译对象的支持。

.. _how-to-create-language-files:

2. 如何创建语言文件
===============================

当您标记了翻译字符串，您就需要写出（或获取已有的）对应的语言翻译信息。 这里就是它如何工作的。

.. admonition:: Locale restrictions

    Django 不支持把您的应用本地化到一个连它自己都还没被翻译的地域。 在这种情况
    下，它将忽略您的翻译文件。 如果您想尝试这个并且 Django 支持它，您会不可避免
    地见到这样一个混合体––参杂着您的译文和来自 Django 自己的英文。 如果您的应
    用需要您支持一个Django中没有的地域，您将至少需要做一个Django core的最小翻译。

消息文件
-------------

第一步，就是为一种语言创建一个信息文件。 信息文件是包含了某一语言翻译字符串和对这些字符串的翻译的一个文本文件。 信息文件以 ``.po`` 为后缀名。

Django 中带有一个工具, ``django-admin.py makemessages``, 它完成了这些文件的创建和维护工作。 

.. admonition:: 旧版Django用户注意

    旧工具 ``bin/make-messages.py`` 在新版本的Django中已经变成
    ``django-admin.py makemessages`` 来提供一贯的支持。

运行以下命令来创建或更新一个信息文件：::

    django-admin.py makemessages -l de

其中 ``de`` 是所创建的信息文件的语言代码。 在这里，语言代码是以本地格式给出的。 例如，巴西地区的葡萄牙语为 ``pt_BR`` 澳大利亚地区的德语为 ``de_AT``  。

这段脚本应该在下面三处的其中一处运行:

    * Django项目根目录。
    * 您Django应用的根目录。
    *  ``django`` 根目录（不是Subversion检出目录，而是通过 ``$PYTHONPATH`` 链接或位于该路径的某处）。这仅和您为Django自己创建一个翻译时有关。另见 :ref:`contributing-translations`.

这段脚本遍历您的项目源树或您的应用程序源树并且提取出所有为翻译而被标记的字符串。 它在  ``locale/LANG/LC_MESSAGES`` 目录下创建（或更新）了一个信息文件。针对上面的 ``de`` 应该是 ``locale/de/LC_MESSAGES/django.po`` 。

默认情况下 ``django-admin.py makemessages`` 会检查每一个扩展名为 ``.html`` 的文件。  以备您要重载缺省值，使用 ``--extension`` 或 ``-e`` 选项指定文件扩展名来检测。::

    django-admin.py makemessages -l de -e txt

用逗号和（或）使用 ``-e`` 或 ``--extension`` 来分割多项扩展名::

    django-admin.py makemessages -l=de -e=html,txt -e xml

当创建JavaScript翻译目录时，您需要使用特殊的Django域： 'djangojs' 域, **not** ``-e js`` 。

.. _create a JavaScript translation catalog: `创建 JavaScript 翻译目录`_

.. admonition:: 没有 gettext?

    如果没有安装 ``gettext`` 组件, ``django-admin.py makemessages`` 会创建空白文件。 这种情况下, 安装  ``gettext`` 组件或只是复制英语信息文件 (``locale/en/LC_MESSAGES/django.po``) 来作为一个起点；只是一个空白的翻译信息文件而已。

.. admonition:: 在 Windows 下工作?

   如果您正在使用Windows，且需要安装GNU gettext共用程序以便 ``django-admin makemessages`` 可以工作。参考下面 `Windows 下的 gettext`_ 获得更多信息。

``.po`` 文件格式很直观。 每个 ``.po`` 文件包含一小部分的元数据，比如翻译维护人员的联系信息，而文件的大部分内容是简单的翻译字符串和对应语言翻译结果的映射关系的列表。

举个例子，如果Django应用程序包括一个
``"Welcome to my site."`` 的待翻译字符串 ，像这样：::

    _("Welcome to my site.")

...则 ``django-admin.py makemessages`` 将创建一个 ``.po`` 文件来包含一下片段信息::

    #: path/to/python/module.py:23
    msgid "Welcome to my site."
    msgstr ""

快速解释:

    * ``msgid`` 是在源文件中出现的翻译字符串。 不要做改动。
    * ``msgstr`` 是相应语言的翻译结果。 刚创建时它只是空字符串，此时就需要您来完成它。 注意不要丢掉语句前后的引号。
    * 作为方便之处，每一个消息都包括：以 `` #``  为前缀的一个注释行并且定位上边的 ``msgid``  行，文件名和行号。

对于比较长的信息也有其处理方法。``msgstr``  （或 ``msgid`` ）后紧跟着的字符串为一个空字符串。 然后真正的内容在其下面的几行。 这些字符串会被直接连在一起。 同时，不要忘了字符串末尾的空格，因为它们会不加空格地连到一起

.. admonition:: 注意您的编码

    当使用您喜好的文字处理器创建一个PO文件的时候, 首先编辑
    charset 那一行 (搜索 ``"CHARSET"``) 并设置charset
    为您使用的charset。 由于gettext工具的工作方式，因为我们
    希望允许在Django的核心和应用程序中允许非ASCII源字符串，
    您必须使用UTF - 8编码的PO文件。
    这就意味着每个人都应该使用同样的编码，这对于Django处理PO文件相当重要。

要重新审视所有的源代码和新的翻译字符串的模板和为所以语言更新消息文件，
运行如下命令 ::

    django-admin.py makemessages -a

编译信息文件
-----------------------

创建信息文件之后，每次对其做了修改，都需要将它重新编译成一种更有效率的形式，供 ``gettext`` 使用。可以使用 ``django-admin.py compilemessages`` 完成 。

这个工具作用于所有有效的 ``.po``  文件，创建优化过的二进制 ``.mo``  文件供 ``gettext`` 使用。在您可以运行 
``django-admin.py  makemessages`` 的目录下，运行 
``django-admin.py compilemessages`` ：::

   django-admin.py compilemessages

就是这样了。 您的翻译成果已经可以使用了。

.. admonition:: 旧版Django用户注意

    旧工具 ``bin/compile-messages.py`` 在新版本的Django中已经变成
    ``django-admin.py compilemessages`` 来提供一贯的支持。

.. admonition:: 在windows下工作?

   如果您正在使用Windows，且需要安装GNU gettext共用程序以便
   ``django-admin compilemessages`` 可以工作。参考 `Windows 下的 gettext`_
   获得更多信息。

.. _how-django-discovers-language-preference:

3. Django如何处理语言偏好
===========================================

一旦您准备好了翻译，如果希望在Django中使用，那么只需要激活这些翻译即可。

在这些功能背后，Django拥有一个灵活的模型来确定在安装和使用应用程序的过程中选择使用的语言。

要设定一个安装阶段的语种偏好，请设定 :setting:`LANGUAGE_CODE`.
如果其他翻译器没有找到一个译文，Django将使用这个语种作为缺省的翻译最终尝试。

如果您只是想要用本地语言来运行Django，并且该语言的语言文件存在，只需要简单地设置
``LANGUAGE_CODE`` 即可。

如果要让每一个使用者各自指定语言偏好，就需要使用 ``LocaleMiddleware``. ``LocaleMiddleware`` 使得Django基于请求的数据进行语言选择，从而为每一位用户定制内容。 它为每一个用户定制内容。

使用 ``LocaleMiddleware``, 需要把 ``'django.middleware.locale.LocaleMiddleware'``
添加到 ``MIDDLEWARE_CLASSES`` 中去（在settings.py）。 中间件的顺序是有影响的，最好按照依照以下要求：:

    * 保证它是第一批安装的中间件类。
    * 因为 ``LocaleMiddleware``
      要用到session数据，所以需要放在 ``SessionMiddleware`` 之后。
    * 如果您使用 ``CacheMiddleware``, 把 ``LocaleMiddleware`` 放在它后面。

例如，您的 ``MIDDLEWARE_CLASSES`` 可能看上去会是这样::

    MIDDLEWARE_CLASSES = (
       'django.contrib.sessions.middleware.SessionMiddleware',
       'django.middleware.locale.LocaleMiddleware',
       'django.middleware.common.CommonMiddleware',
    )

(关于更多中间件的内容, 请参见 :ref:`middleware documentation
<topics-http-middleware>`.)

``LocaleMiddleware`` 按照如下算法确定用户的语言:

    * 首先，在当前用户的 session 的中查找 ``django_language`` 键。

    * 如未找到，它会找寻一个cookie。

      .. versionchanged:: 1.0

      在 Django  0.96版本 或 更早的版本当中,  cookie 的名字是被硬编码成 ``django_language`` 的。在 Django 1,0中, 这个cookie 的名字使用 ``LANGUAGE_COOKIE_NAME`` 来设置. (默认为 ``django_language`` .)

    * 还找不到的话，它会在 HTTP 请求头部里查找 ``Accept-Language`` 该头部是您的浏览器发送的，并且按优先顺序告诉服务器您的语言偏好。 Django会尝试头部中的每一个语种直到它发现一个可用的翻译。

    * 以上都失败了的话, 就使用全局的 ``LANGUAGE_CODE`` 设置。

.. _locale-middleware-notes:

Notes:

    * 在上述每一处，语种偏好应作为字符串，以标准的语种格式出现。 例如，巴西葡萄牙语是 ``pt-br`` 。

    * 如果一个基本语种存在而亚语种没有指定，Django将使用基本语种。 比如，如果用户指定了 ``de-at`` （澳式德语）但Django只有针对 ``de`` 的翻译，那么
      ``de`` 将会被选用。

    * 只有在 :setting:`LANGUAGES` 设置中列出的语言才能被选用。
      若希望将语言限制为所提供语言中的某些（因为应用程序并不提供所有语言的表示），则将 ``LANGUAGES`` 设置为所希望提供语言的列表，例如：::

          LANGUAGES = (
            ('de', _('German')),
            ('en', _('English')),
          )

      上面这个例子限制了语言偏好只能是德语和英语（包括它们的子语言，如 de-ch 和 en-us ）。

      .. _LANGUAGES setting: ../settings/#languages

    * 如果自定义了 ``LANGUAGES`` , 如前面解释，
      可以使用“虚拟的” ``ugettext()`` 来标记需要翻译的字符串，
      而不是使用 ``django.utils.translation`` 中的。千万不要在settings文件里引入 
      ``django.utils.translation`` , 因为这个模块本身依赖于这个settings
      这将引发一个循环的引入。

      解决方案是使用一个 "虚拟的" ``ugettext()`` . 以下是一个settings文件的例子 ::

          ugettext = lambda s: s

          LANGUAGES = (
              ('de', ugettext('German')),
              ('en', ugettext('English')),
          )

      这样做的话, ``django-admin.py makemessages`` 仍会寻找并标记出将要被翻译的这些字符串，但翻译不会在运行时进行，故而需要在任何使用 ``LANGUAGES`` 的代码中用 *真实的* ``ugettext()`` 。
      
      *  ``LocaleMiddleware`` 只能选择那些Django已经提供了基础翻译的语言。 如果想要在应用程序中对Django中还没有基础翻译的语言提供翻译，那么必须至少先提供该语言的基本的翻译。 例如，Django使用特定的信息ID来翻译日期和时间格式，故要让系统正常工作，至少要提供这些基本的翻译。

      以英语的 ``.po`` 文件为基础，翻译其中的技术相关的信息，可能还包括一些使之生效的信息。

      技术相关的信息ID很容易被认出来：它们都是大写的。 这些信息ID的翻译与其他信息不同:您需要提供其对应的本地化内容。例如，对于
      ``DATETIME_FORMAT`` (或 ``DATE_FORMAT`` 或 ``TIME_FORMAT``), 应该提供希望在该语言中使用的格式化字符串。 格式被模板标签 ``now`` 用来识别格式字符串。

一旦 ``LocaleMiddleware`` 决定用户的偏好，它会让这个偏好作为 ``request.LANGUAGE_CODE`` 对每一个
:class:`~django.http.HttpRequest` 有效。请随意在您的视图代码中读一读这个值。 以下是一个简单的例子：::

    def hello_world(request, count):
        if request.LANGUAGE_CODE == 'de-at':
            return HttpResponse("You prefer to read Austrian German.")
        else:
            return HttpResponse("You prefer to read another language.")

注意，对于静态翻译（无中间件）而言，此语言在
``settings.LANGUAGE_CODE``, 中，而对于动态翻译（中间件），它在 ``request.LANGUAGE_CODE`` 中。

.. _settings file: ../settings/
.. _middleware documentation: ../middleware/
.. _session: ../sessions/
.. _request object: ../request_response/#httprequest-objects

.. _translations-in-your-own-projects:

在您自己的的项目中使用译文
=======================================

Django会按照一下算法寻找译文 :

    * 首先,当view被调用的时候它会在当前应用程序所在的文件夹中寻找一个名为 ``locale`` 的文件夹。如果找到了指定语言的译文，它们将会被加载。
    * 在第一步没有找到的情况下, Django会在工程目录下寻找 ``locale`` 目录。同样的，如果找到译文就加载；如果没有找到则进行下一步。
    * 最后, Django将在 Django提供的基本译文 
      ``django/conf/locale`` 中寻找。

所以, 您可以在一个应用程序中使用自己的译文；
您也可以在您的工程目录下覆盖基本译文； 或者, 您可以写一个应用里面包含了所有应用的译文。
这全都取决于您。

.. note::

    如果您是手动配置的settings, 如
    :ref:`settings-without-django-settings-module` 中描述的那样, 工程目录下的 ``locale`` 文件夹将
    不会被检测,  Django 失去
    获得工程目录路径的能力. (Django normally uses the
    location of the settings file to determine this, and a settings file doesn't
    exist if you're manually configuring your settings.)

所有的信息文件库都是以同样方式组织的, 它们是 :

    * ``$APPPATH/locale/<language>/LC_MESSAGES/django.(po|mo)``
    * ``$PROJECTPATH/locale/<language>/LC_MESSAGES/django.(po|mo)``
    * 所有在 ``LOCALE_PATHS`` 中列出的路径
      以其列出的顺序搜索 ``<language>/LC_MESSAGES/django.(po|mo)``
    * ``$PYTHONPATH/django/conf/locale/<language>/LC_MESSAGES/django.(po|mo)``

要创建信息文件，也是使用 ``django-admin.py makemessages``
工具，和Django信息文件一样。 需要做的就是进入正确的目录
--  ``conf/locale`` (在源码树的情况下) 或者 ``locale/`` (在应用程序信息或项目信息的情况下)
所在的目录下。同样的，使用 ``django-admin.py compilemessages``
生成 ``gettext`` 需要使用的二进制 ``django.mo`` 文件。 

您也可以运行 ``django-admin.py compilemessages --settings=path.to.settings``
来使编译器处理所有存在于您 ``LOCALE_PATHS``
设置中的目录。

应用程序信息文件稍微难以发现——因为它们需要
``LocaleMiddleware``. 如果不使用中间件，Django只会处理Django的信息文件和项目的信息文件。

最后，需要考虑一下翻译文件的结构。 若应用程序要发放给其他用户，
应用到其它项目中，可能需要使用应用程序相关的翻译。 但是，
使用应用程序相关的翻译和项目翻译在使用 ``makemessages`` 时会产生古怪的问题。 ``makemessages`` 会
遍历当前路径下所有的文件夹，这样可能会把应用消息文件里存在的
消息ID重复放入项目消息文件中。

最容易的解决方法就是将不属于项目的应用程序（因此附带着本身的翻译）存储在项目树之外。 这样做的话，项目级的
``django-admin.py makemessages`` 将只会翻译与项目精确相关的，而不包括那些独立发布的应用程序中的字符串。

重定向视图 ``set_language`` 
==================================

方便起见，Django自带了一个 ``django.views.i18n.set_language`` 视图,
作用是设置用户语言偏好并重定向返回到前一页面。

在URLconf中加入下面这行代码来激活这个视图 ::

    (r'^i18n/', include('django.conf.urls.i18n')),

(注意这个例子使得这个视图在 ``/i18n/setlang/`` 中有效。)

这个视图是通过 ``POST`` 方法调用的，在请求中包含了 ``language``
参数。 如果session已启用，这个视图会将语言选择
保存在用户的session中。 否则，它会以缺省名 ``django_language`` 。
在cookie中保存这个语言选择。(这个名字可以通过 ``LANGUAGE_COOKIE_NAME`` 设置来改变。)

保存了语言选择后，Django根据以下算法来重定向页面:

    * Django 在 ``POST`` 数据中 寻找 ``next`` 参数。
    * 如果 ``next`` 参数不存在或为空，Django尝试重定向页面为HTML头部信息中
      ``Referrer`` 的值。
    * 如果 ``Referrer`` 也是空的，即该用户的浏览器并不发送 ``Referrer`` 头信息，
      则页面将重定向到 ``/`` (页面根目录) 。

这是一个HTML模板代码的例子:

.. code-block:: html+django

    <form action="/i18n/setlang/" method="post">
    <input name="next" type="hidden" value="/next/page/" />
    <select name="language">
    {% for lang in LANGUAGES %}
    <option value="{{ lang.0 }}">{{ lang.1 }}</option>
    {% endfor %}
    </select>
    <input type="submit" value="Go" />
    </form>

翻译与 JavaScript
===========================

将翻译添加到JavaScript会引起一些问题:

    * JavaScript代码无法访问一个 ``gettext`` 的实现。

    * JavaScript 代码并不访问 .po或 .mo 文件；它们需要由服务器分发。

    * 针对JavaScript的翻译目录应尽量小。

Django 已经提供了一个集成解决方案： 它会将翻译传递给JavaScript，
因此就可以在JavaScript中调用 ``gettext`` 之类的代码。

``javascript_catalog`` 视图
----------------------------

这些问题的主要解决方案就是 ``javascript_catalog`` 视图。
该视图生成一个JavaScript代码库，包括模仿  ``gettext``
接口的函数，和翻译字符串的数组。 这些翻译字符串来自于您在
info_dict或URl中指定的应用，工程或Django内核。

像这样使用 ::

    js_info_dict = {
        'packages': ('your.app.package',),
    }

    urlpatterns = patterns('',
        (r'^jsi18n/$', 'django.views.i18n.javascript_catalog', js_info_dict),
    )

``packages`` 里的每个字符串应该是Python中的点分割的包的表达式形式
(和在 ``INSTALLED_APPS`` 中的字符串相同的格式) 而且应指向
包含 ``locale`` 目录的包。如果指定了多个包，所有的目录会合并成一个目录。 
如果有用到来自不同应用程序的字符串的JavaScript，这种机制会很有帮助。

您可以动态使用视图，将包放在 URL pattern里 ::

    urlpatterns = patterns('',
        (r'^jsi18n/(?P<packages>\S+?)/$', 'django.views.i18n.javascript_catalog'),
    )

这样的话，就可以在URL中指定由加号（ + ）分隔包名的包了。 
如果页面使用来自不同应用程序的代码，且经常改变，
还不想将其放在一个大的目录文件中，对于这些情况，显然这是很有用的。
出于安全考虑，这些值只能是
``django.conf`` 或 ``INSTALLED_APPS`` 设置中的包。

使用 JavaScript 翻译目录
------------------------------

要使用这个目录，只要这样引入动态生成的脚本 ::

    <script type="text/javascript" src="{% url django.views.i18n.javascript_catalog %}"></script>

这就是管理页面如何从服务器获取翻译目录。当目录加载后，JavaScript 代码就能通过
标准的 ``gettext`` 接口进行访问::

    document.write(gettext('this is to be translated'));

还有一个 ``ngettext`` 接口 ::

    var object_cnt = 1 // or 0, or 2, or 3, ...
    s = ngettext('literal for the singular case',
            'literal for the plural case', object_cnt);

甚至有一个字符串插入函数 ::

    function interpolate(fmt, obj, named);

插入句法是从Python借用的，所以 ``interpolate``
函数对位置和命名插入均提供支持:

    * 位置插入: ``obj``  包括一个JavaScript数组对象,
      元素值在它们对应于 ``fmt`` 的占位符中以它们出现的相同次序顺序插值。
      例如 ::

        fmts = ngettext('There is %s object. Remaining: %s',
                'There are %s objects. Remaining: %s', 11);
        s = interpolate(fmts, [11, 20]);
        // s is 'There are 11 objects. Remaining: 20'

    * 命名插入 通过传送为真（TRUE）的布尔
      参数 ``named`` 来选择这个模式。 ``obj`` 包括一个 JavaScript 对象或相关数组。
      例如 ::

        d = {
            count: 10
            total: 50
        };

        fmts = ngettext('Total: %(total)s, there is %(count)s object',
        'there are %(count)s of a total of %(total)s objects', d.count);
        s = interpolate(fmts, d, true);

但是，您不应重复编写字符串插值： 这还是JavaScript，所以这段代码不得不重复做正则表达式置换。
它不会和Python中的字符串插补一样快，因此只有真正需要的时候再使用它（例如，利用 ``ngettext`` 
生成合适的复数形式）。

创建 JavaScript 翻译目录
----------------------------------------

您可以创建和更改翻译目录，就像其他

Django翻译目录一样，使用django-admin.py makemessages 工具。
唯一的差别是需要提供一个 ``-d djangojs`` 的参数, 就像这样 ::

    django-admin.py makemessages -d djangojs -l de

这样来创建或更新JavaScript的德语翻译目录。
和普通的Django翻译目录一样，更新了翻译目录后，运行 ``django-admin.py compilemessages`` 
即可。

Django 翻译中的一些特殊情况
==================================

如果您了解 ``gettext``, 您可能会发现Django进行翻译时的一些特殊的东西:

    * 字符串域为 ``django`` 或 ``djangojs`` 。 字符串域是用来区别将数据存储在同一信息文件库
      (一般是 ``/usr/share/locale/``)的不同程序。 
      ``django`` 域是为Python和模板翻译字符串服务的，
      被加载到全局翻译目录。 ``djangojs``
      域只是用来尽可能缩小JavaScript翻译的体积。
    * Django不单独使用 ``xgettext`` ， 而是经过Python包装后的
      ``xgettext`` 和 ``msgfmt`` 。 这主要是为了方便。

Windows 下的 ``gettext``
========================

对于那些要提取消息或编译消息文件的人们来说，需要的只有这么多。翻译工作本身仅仅包含编辑这个类型的
现存文件，但如果您要创建您自己的消息文件，或想要测试或编译一个更改过的消息文件，您将需要这
个 ``gettext`` 共用程序:

    * 从 GNOME 的服务器
      http://ftp.gnome.org/pub/gnome/binaries/win32/dependencies/ 或镜像服务器
      mirrors_ 上下载以下文件。

      * ``gettext-runtime-X.zip``
      * ``gettext-tools-X.zip``

      ``X`` 代表版本号, 建议使用 ``0.15`` 或 更高。

    * 在同一文件夹下展开这3个文件。（也就是 ``C:\Program Files\gettext-utils`` ）

    * 更新系统路径:

      * ``控制面板 > 系统 > 高级 > 环境变量``
      * 在 ``系统变量`` 列表中，点击 ``路径`` ，点击 ``编辑``
      * 把 ``;C:\Program Files\gettext-utils\bin`` 加到 ``变量值`` 字段的末尾。

.. _mirrors: http://ftp.gnome.org/pub/GNOME/MIRRORS

只要 ``xgettext --version`` 命令正常工作，您亦可使用从别处获得的 ``gettext`` 的
二进制代码。 有些版本的0.14.4二进制代码被发现不支持这个命令。 不要试图与 Django
公用程序一起使用一个 ``gettext`` 。在一个windows命令提示窗口输入命令
``xgettext —version`` 将导致出现一个错误弹出窗口–“xgettext.exe产生错误并且将
被windows关闭”。

