.. _topics-db-queries:

==============
构造查询
==============

.. currentmodule:: django.db.models

一旦创建完 :ref:`data models <topics-db-models>` ， Django 会自动给你一套数据库
抽象的 API ，以用于创建、检索、更新和删除对象。本文为你介绍如何使用这套 API 。
所有不同种类的搜索参数详见 :ref:`data model reference <ref-models-index>` 。

本文所有内容（包括本手册）全部围绕以下模型展开，这些模型可以组成一个博客应用：

.. _queryset-model-example:

.. code-block:: python

    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def __unicode__(self):
            return self.name

    class Author(models.Model):
        name = models.CharField(max_length=50)
        email = models.EmailField()

        def __unicode__(self):
            return self.name

    class Entry(models.Model):
        blog = models.ForeignKey(Blog)
        headline = models.CharField(max_length=255)
        body_text = models.TextField()
        pub_date = models.DateTimeField()
        authors = models.ManyToManyField(Author)
        n_comments = models.IntegerField()
        n_pingbacks = models.IntegerField()
        rating = models.IntegerField()

        def __unicode__(self):
            return self.headline

创建对象
========

为在 Python 对象中表现数据库表中的数据， Django 使用一个非常直观的系统：一个
模型类表现一个数据库表，并且一个该类的实例表现表中一个指定的记录。

要创建一个对象，只要通过使用关键参数实例化模型类，然后调用 ``save()`` 把对象
保存到数据库就行了。

你可以从任何 Python 路径导入模型类。（我们之所以要指出这点是因为旧版本 Django
导入模型没有这么方便。）

假设模型存在于文件 ``mysite/blog/models.py`` 中，示例如下::

    >>> from mysite.blog.models import Blog
    >>> b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
    >>> b.save()

上例在后执行了一个 ``INSERT`` SQL 语句。 Django 不会执行数据库操作，除非显式
调用 ``save()`` 。

``save()`` 方法没有返回值。

.. seealso::

    ``save()`` 有许多高级参数这里没有提到，详见其文档。

    要一步完成创建并且同时保存对象参见 ```create()``` 方法。

修改对象
========

要修改数据库中已存在的对象，请使用 ``save()`` 。

假设一个 ``Blog`` 的实例 ``b5`` ，这个实例已经保存进了数据库，以下例子会修改其
name 并且会修改数据库中相应的数据::

    >> b5.name = 'New name'
    >> b5.save()

上例在后执行了一个 ``UPDATE`` SQL 语句。 Django 不会执行数据库操作，除非显式
调用 ``save()`` 。 

保存 ``ForeignKey`` 和 ``ManyToManyField`` 字段
-----------------------------------------------

更新 ``ForeignKey`` 字段的方法与一般的字段一样，只要设置正确的字段类型就可以
了::

    >>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
    >>> entry.blog = cheese_blog
    >>> entry.save()

更新一个 ``ManyToManyField`` 字段稍有不同，要对更新的字段使用 ``add()`` 方法来
为关系增加一个记录::

    >> joe = Author.objects.create(name="Joe")
    >> entry.authors.add(joe)

如果你尝试使用不正确的对象类型，那么 Django 会有意见的。

获取对象
========

要从你的数据库中获得对象，你必须通过你的模型类的 ``管理器（ Manager ）`` 来构建
一个 ``查询集（ QuerySet ）`` 。

一个 ``查询集`` 表现为数据库中对象的集合。它可以没有、有一个或有多个
*过滤器（ filters ）* 。过滤器是限制集合范围的准则。在 SQL 语句中，一个
``查询集`` 等于一个 ``SELECT`` 语句，一个过滤器相当于一个 ``WHERE`` 或
``LIMIT`` 子句。

你可以通过使用模型的 ``管理器`` 得到一个 ``查询集`` 。每个模型至少有一个
``管理器`` ，``管理器`` 一般也称作 ``对象（ objects ）`` 。 ``管理器`` 可以通过
模型类直接操作，就如下例::

    >>> Blog.objects
    <django.db.models.manager.Manager object at ...>
    >>> b = Blog(name='Foo', tagline='Bar')
    >>> b.objects
    Traceback:
        ...
    AttributeError: "Manager isn't accessible via Blog instances."

.. note::

    ``管理器`` 只能由模型类操作，而不能由模型实例操作。这样用以区别
    ``表级别`` 操作和 ``记录级别`` 操作。

``管理器`` 是一个模型的 ``查询集`` 的主要来源，它类似于模型的数据库表中所有对象
的“根” ``查询集`` 。例如， ``Blog.objects`` 是包含 ``Blog`` 数据库表中所有
对象的初始 ``查询集`` 。

获得所有对象
----------------------

从数据库表中获得对象的最简单的方法就是获得所有对象。在一个 ``管理器`` 上使用
``all()`` 方法可以获得所有对象::

    >>> all_entries = Entry.objects.all()

``all()`` 方法返回一个包含所有数据库表中对象的 ``查询集`` 。

（既然 ``Entry.objects`` 是一个 ``查询集`` ，为什么不使用 ``Entry.objects`` ？
这是因为 ``Entry.objects`` ，是一个根 ``查询集`` ，是一个不能表现出来的东西。
``all()`` 方法返回的是 *可以* 表现出来的 ``查询集`` 。

用过滤器获得特定对象
--------------------

根 ``查询集`` 通过 ``管理器`` 提供数据库表的所有对象的描述。但是通常你只需要
全部对象的一个子集。

要得到这个子集，就必须改进原始的 ``查询集`` ，增加一些过滤条件，通常使用以下
两种方法：

    ``filter(**kwargs)``
        返回一个新的包含符合查询条件对象的 ``查询集`` 。

    ``exclude(**kwargs)``
        返回一个新的 *不* 包含符合查询条件对象的 ``查询集`` 。

查询参数（即上例中的 ``**kwargs`` ）应当遵循下文 `字段查找`_ 一节中描述的规则。

例如，要获得一个包含所有 2006 年的博客条目的 ``查询集`` ，可以这样使用
``filter()`` ::

    Entry.objects.filter(pub_date__year=2006)

这里我们不需要添加一个 ``all()`` -- ``Entry.objects.all().filter(...)`` 。当然
添加了也可以，但是一般只有在需要从根 ``查询集`` 中获取所有对象时才使用
``all()`` 。

.. _chaining-filters:

连环过滤器
~~~~~~~~~~

``过滤器`` 可以连环使用，例如::

    >>> Entry.objects.filter(
    ...     headline__startswith='What'
    ... ).exclude(
    ...     pub_date__gte=datetime.now()
    ... ).filter(
    ...     pub_date__gte=datetime(2005, 1, 1)
    ... )

上例中在原始的包含所有记录的 ``查询集`` 上加上了一个过滤器，再加上了一个排除，
最后再加上了一个过滤器。最后得到的是一个 headline 以 "What" 开头的，发布时间
介于 2005 年 1 月 1 日和当前时间之间的 ``查询集`` 。

.. _filtered-querysets-are-unique:

过滤后的查询集是独立唯一的
~~~~~~~~~~~~~~~~~~~~~~~~~~

每一次提取的 ``查询集`` 都是独立的、唯一的，是与前一次的 ``查询集`` 无关的，是
可以储存、使用和再使用的。

例如::

    >> q1 = Entry.objects.filter(headline__startswith="What")
    >> q2 = q1.exclude(pub_date__gte=datetime.now())
    >> q3 = q1.filter(pub_date__gte=datetime.now())

以上三个 ``查询集`` 是独立的。第一个是一个基础 ``查询集`` ，包含所有 headline
以 "What" 开头的记录。第二个 ``查询集`` 是第一个的子集，去除了发布时间晚于当前
时间的记录。第三个 ``查询集`` 是第一个的子集，只含有发布时间晚于当前时间的
记录。原始的 ``查询集`` （ ``q1`` ）不会因为后面的添加限制条件而改变。

.. _querysets-are-lazy:

查询集是惰性的
~~~~~~~~~~~~~~

``查询集`` 是惰性的，即创建一个 ``查询集`` 不会触动数据库。你可以不停地创建
过滤器，但 Django 不会真正运行查询，除非 ``查询集`` 被 *执行* 了。来看以下的
例子::

    >>> q = Entry.objects.filter(headline__startswith="What")
    >>> q = q.filter(pub_date__lte=datetime.now())
    >>> q = q.exclude(body_text__icontains="food")
    >>> print q

上例中表面看执行了三个数据库查询，但实质只有最后一行代码（ ``print q`` ）执行了
一次数据库查询。通常，只到你“要求”返回结果时， ``查询集`` 才会从数据库中抓取
数据， ``查询集`` 被 *执行* 了。更多关于执行的精确时间的内容参见
:ref:`when-querysets-are-evaluated` 。

其他查询集方法
~~~~~~~~~~~~~~

大多数时间，当需要在数据库中查找对象时会使用 ``all()`` 、 ``filter()`` 和
``exclude()`` 。但是，这还是远远不够的。要得到所有 ``查询集`` 方法的完整列表，请
参阅 :ref:`查询集 API 手册 <queryset-api>` 。

.. _limiting-querysets:

限制查询集
----------

可以使用 Python 序列切片语法的子集来限制你的 ``查询集`` 。这将相当于 SQL 的
``LIMIT`` 和 ``OFFSET`` 子句。

例如，下例返回前五个对象（ ``LIMIT 5`` ）::

    >>> Entry.objects.all()[:5]

下例返回第六到第十个对象（ ``OFFSET 5 LIMIT 5`` ）::

    >>> Entry.objects.all()[5:10]

负数索引（如： ``Entry.objects.all()[-1]`` ）是不支持的。

通常，对一个 ``查询集`` 切片只会返回一个新的 ``查询集`` ，不会执行这个查询 。
但是有一个例外：假如使用 Python 语法中的“步长”参数，那么就会执行查询。下例用于
返回前十个对象中的第偶数个对象，查询会立即执行::

    >>> Entry.objects.all()[:10:2]

要得到一个 *单一* 的对象而不是一个列表（如：
``SELECT foo FROM bar LIMIT 1`` ），可以使用一个简单的索引，而不使用切片。例如
下例返回数据中按字母排序后的第一条记录::

    >>> Entry.objects.order_by('headline')[0]

上例基本上等同于::

    >>> Entry.objects.order_by('headline')[0:1].get()

注意：当查询结果为空时，第一个例子会产生 ``IndexError`` 异常，而第二个例子则
产生 ``DoesNotExist`` 异常。详见 ``get()`` 。

.. _field-lookups-intro:

字段查找
--------

字段查找的定义相当于书写 SQL 的 ``WHERE`` 子句。定义方法是把条件作为 ``查询集``
的 ``filter()`` 、 ``exclude()`` 和 ``get()`` 方法的关键字参数。

基本的查找关键字参数形如： ``字段__查找类型=值`` （注意：是双下划线）。
例如::

    >>> Entry.objects.filter(pub_date__lte='2006-01-01')

翻译为 SQL 语句大致如下::

    SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';

.. admonition:: 这是如何做到的

   Python 中的函数可以接受独特的名称-值参数，并且这些参数可以动态赋值。更详细的
   信息参见官方 Python 教程的 `关键字参数`_ 。

   .. _`关键字参数`: http://docs.python.org/tut/node6.html#SECTION006720000000000000000

如果你传递了一个非法的关键字参数，会产生 ``TypeError`` 。

查找类型约有二十多个，详见 :ref:`字段查找手册<field-lookups>` 。以下是一些常用
的查找例子：

    :lookup:`exact`
        “精确”匹配。例如::

            >>> Entry.objects.get(headline__exact="Man bites dog")

        相当于以下 SQL 语句：

        .. code-block:: sql

            SELECT ... WHERE headline = 'Man bites dog';

        如果没有定义查找类型，即没有使用双下划线，那么默认类型为 ``exact`` 。

        例如以下两句是等价的::

            >>> Blog.objects.get(id__exact=14)  # 显式声明
            >>> Blog.objects.get(id=14)         # __exact 隐含在内了

        这样做是为了方便，因为 ``exact`` 查找是最常用的。

    :lookup:`iexact`
        一个大小写不敏感的匹配。所以下例::

            >>> Blog.objects.get(name__iexact="beatles blog")

        将会匹配标题为 “Beatles Blog ”、“ beatles blog ”或甚至是
        “ BeAtlES blOG ”的 ``Blog`` 。

    :lookup:`contains`
        大小写敏感的包含测试。例如::

            Entry.objects.get(headline__contains='Lennon')

        基本相当于以下 SQL：

        .. code-block:: sql

            SELECT ... WHERE headline LIKE '%Lennon%';

        注意这个查找会匹配 ``'Today Lennon honored'`` ，但是不会匹配
        ``'today lennon honored'``.

        当然也有大小不敏感的： :lookup:`icontains` 。

    :lookup:`startswith`, :lookup:`endswith`
        大小写敏感的匹配开头和结尾。相应大小写不敏感的是 :lookup:`istartswith`
        和 :lookup:`iendswith` 。

再次重申，以下介绍只是一些皮毛。完整的手册详见
:ref:`字段查找手册<field-lookups>` 。

跨关系查找
----------

Django 提供一个有力且直观的方法来“追踪”查找中的关系，即会在后台自动处理 SQL
中的 ``JOIN`` 。要跨越一个关系，只要使用跨模块的关联字段即可，并用两个下划线
分隔，直到得到你想要的字段为止。

以下例子可以获得名称为 ``'Beatles Blog'`` 的 ``Blog`` 的所有条目。

    >>> Entry.objects.filter(blog__name__exact='Beatles Blog')

这种跨越的深度是无限的。

跨越也可以是反向的。要指向一个“反向”的关系，请使用模型的小写名称。

下例可以获得至少一个条目的头条包含 ``'Lennon'`` 的所有 ``Blog`` 对象::

    >>> Blog.objects.filter(entry__headline__contains='Lennon')

如果你跨越了多重关系并且其中的一个模型没有符合条件的值，那么 Django 会把模型视作
空对象（即所有值为 ``NULL`` ），而不是非法对象。因此在前述情况下不会引发错误。
例如::

    Blog.objects.filter(entry__author__name='Lennon')

假设有一个相关联的 ``作者``（ Author ）模型，如果没有 ``作者`` 与任何一个条目
关联，那么就会视作也没有 ``名称`` 与之关联。这样处理比因为 ``作者`` 缺失而引发
错误要好。通常这也是你想要的处理方式。唯一会产生混淆的是当你使用 ``isnull`` 的
时候。就象下例::

    Blog.objects.filter(entry__author__name__isnull=True)

会返回包括 ``名字`` 为空的 ``作者`` 和 ``作者`` 为空的 ``条目`` 两种情况的
``Blog`` 对象。如果你不希望包括后一种情况的对象，你可以这样写::

    Blog.objects.filter(entry__author__isnull=False,
            entry__author__name__isnull=True)

跨越多值关系
~~~~~~~~~~~~

.. versionadded:: 1.0

当你基于一个 ``多对多字段`` 对象或一个反向 ``外键字段`` 过滤时，有两种不同的过滤
方法值得注意。对于 ``博客`` 与 ``条目`` 关系（ ``博客`` 对于 ``条目`` 是一对多
关系），我们可能会想要查找一个博客，这个必须博客包括一个符合以下条件的条目：在
条目的头条中包含 *"Lennon"* 字样，并且发布日期为 2008 年。或者我们也可以会想要
查找一个博客，这个博客必须符合以下条件：包含一个头条中有 *"Lennon"* 字样的条目，
并且包含一个发布日期为 2008 年的条目。因为一个 ``博客`` 对应于多个 ``条目`` ，
所以上述两种查询都是可能的，在特定情况下都是有用的。

同样，一个 ``多对多字段`` 也会引发类似情况。例如，假设一个 ``条目`` 字段有一个
名为 ``标记`` （ tags ）的多对多字段。我们可以会想要查找既有 *"music"* 标记又有
*"bands"* 标记的条目。或者我们也可能会想要查找标记为 *"music"* ，状态为
*"public"* 的条目。

对于上述两种方法， Django 中的 ``filter()`` 和 ``exclude()`` 使用相同的方式来
处理。在一个 ``filter()`` 中的所有条件必须同时符合。在连续的 ``filter()`` 中的
条件对于多值关系情况下，这些条件是并列的（都对应于主模型的对象），而不是嵌套的
（对应于前一个 ``filter()`` 产生的对象）。

都迷糊了吧，来一个例子清醒一下。要查找一个博客，这个必须博客包括一个符合以下
条件的条目：在条目的头条中包含 *"Lennon"* 字样，并且发布日期为 2008 年。即条目
必须同时符合两个条件。我们这样写::

    Blog.objects.filter(entry__headline__contains='Lennon',
            entry__pub_date__year=2008)

要查找一个博客，这个博客必须符合以下条件：包含一个头条中有 *"Lennon"* 字样的
条目，并且包含一个发布日期为 2008 年的条目。但对于同一个条目不一定要同时符合
两个条件。我们这样写::

    Blog.objects.filter(entry__headline__contains='Lennon').filter(
            entry__pub_date__year=2008)

在第二个例子中，第一个过滤器限定了特定条件的博客，第二个过滤器 *进一步* 限定了
同时符合第二个条件的博客。匹配第二个过滤器的条目不一定匹配第一个过滤器。两个
过滤器的条件都是针对某个博客而言的，而不是针对某个条目而言的。

以上方式也同样用于 ``exclude()`` 。

.. _query-expressions:

过滤器可以引用模型中的字段
--------------------------

.. versionadded:: 1.1

迄今为止的例子中，我们构建的过滤器都是比较字段和常量的，但是如果我们要比较同一
模型中的两个不同字段怎么办？

Django 提供了 ``F()`` 对象来做这样在比较。 ``F()`` 对象查询中可以作为模型字段的
引用，这样就可以在查询中比较同一模型实例中的不同字段了。

例如，我们要查找评论比广播（ pingback ）多的条目，那么先构建一个引用评论数量的
``F()`` 对象，然后在查询中使用这个 ``F()`` 对象::

    >>> from django.db.models import F
    >>> Entry.objects.filter(n_pingbacks__lt=F('n_comments'))

Django 支持 ``F()`` 对象的加减乘除和取模运算。要查找广播数为评论数两倍的条目
可以使用如下查询::

    >>> Entry.objects.filter(n_pingbacks__lt=F('n_comments') * 2)

要查找广播数和评论数之和大于级别的条目可以使用如下查询::

    >>> Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks'))

你也可以在 ``F()`` 对象中使用双下划线来跨越关系。带有双下划线的 ``F()`` 对象会
自动使用必须联合。例如查找所有作者为博客名称的条目，可以使用如下查询：

    >>> Entry.objects.filter(author__name=F('blog__name'))

pk 缩写
----------------------

为了方便， Django 提供了一个 ``pk`` 缩写来代表“主键”。

在博客模型例子中，主键是 ``id`` 字段，所以以下三条语句是等价的::

    >>> Blog.objects.get(id__exact=14) # Explicit form
    >>> Blog.objects.get(id=14) # __exact is implied
    >>> Blog.objects.get(pk=14) # pk implies id__exact

``pk`` 的用法不只局限于 ``__exact`` 查询，任何查询短语都可以::

    # Get blogs entries with id 1, 4 and 7
    >>> Blog.objects.filter(pk__in=[1,4,7])

    # Get all blog entries with id > 14
    >>> Blog.objects.filter(pk__gt=14)

``pk`` 查询还可以用于联合。例如以下语句是等价的::

    >>> Entry.objects.filter(blog__id__exact=3) # Explicit form
    >>> Entry.objects.filter(blog__id=3)        # __exact is implied
    >>> Entry.objects.filter(blog__pk=3)        # __pk implies __id__exact

LIKE 语句中的百分号和下划线的转义
---------------------------------

在相当于 ``LIKE`` SQL 语句的字段查找（ ``iexact`` 、 ``contains`` 、
``icontains`` 、 ``startswith`` 、 ``istartswith`` 、 ``endswith`` 和
``iendswith`` ）中的百分号和下划线会被自动转义。（在 ``LIKE`` 语句中，百分号是
一个代表多个字符的通配符，下划线是一个代表单个字符的通配符。）

这种方式使用语句看起来比较直观。例如，要查询所有包含百分号的条目，可以象对待
其它字符一样对待百分号::

    >>> Entry.objects.filter(headline__contains='%')

Django 会帮你处理引号，上例的相应的 SQL 如下：

.. code-block:: sql

    SELECT ... WHERE headline LIKE '%\%%';

对下划线的处理方法与之相同。这样可以直观地处理百分号和下划线。

.. _caching-and-querysets:

缓存和查询集
------------

每个 ``查询集`` 都包含一个缓存，用于最小化数据库使用。为了写出最有效率的代码，
理解缓存的工作方式是非常重要的。

当一个 ``查询集`` 新建时，其缓存是空的。当 ``查询集`` 第一次被执行时，数据库就
会使用一次， Django 会把查询结果保存在 ``查询集`` 的缓存中并返回结果。以后的
查询就会重复使用缓存。

你要小心缓存的行为，如果不正确使用 ``查询集`` ，那么有可能上当。例如下列语句会
创建两个 ``查询集`` 并执行它们，然后把它们抛在一边::

    >>> print [e.headline for e in Entry.objects.all()]
    >>> print [e.pub_date for e in Entry.objects.all()]

这意味着两个同样的查询被执行了两次，浪费啊。同时，两条语句的条目还可能不一致，
因为在两次查询之间可能会有条目增减。

要避免以上问题，只要保存 ``查询集`` 并且重复使用就可以了::

    >>> queryset = Poll.objects.all()
    >>> print [p.headline for p in queryset] # 执行查询集。
    >>> print [p.pub_date for p in queryset] # 重复使用缓存。

.. _complex-lookups-with-q:

使用 Q 对象进行复杂查询
=======================

在 ``filter()`` 等语句中的关键字查询参数都是“与”的关系。如果要进行更复杂的查询
（如条件之间为“或”的关系），那么可以使用 ``Q`` 对象。

``Q`` 对象（ ``django.db.models.Q`` ）是用于封装一堆关键字查询参数的对象。这些
关键字查询参数在上文“字段查找”中已描述过。

例如，下面的 ``Q`` 对象封装了一个单一的 ``LIKE`` 查询::

    Q(question__startswith='What')

``Q`` 对象可以用 ``&`` 和 ``|`` 操作符联结，联结之后会产生一个新的 ``Q`` 对象。

下例产生了一个新的 ``Q`` 对象，这个对象表示两个 ``"question__startswith"``
查询的 ``OR`` 的联结。

    Q(question__startswith='Who') | Q(question__startswith='What')

上例相当于下面的 SQL ``WHERE`` 子句::

    WHERE question LIKE 'Who%' OR question LIKE 'What%'

可以用 ``&`` 和 ``|`` 操作符及圆括号来组合任意复杂的 ``Q`` 对象，还可以使用
``~`` 符号来表示”逻辑非“。例如::

    Q(question__startswith='Who') | ~Q(pub_date__year=2005)

每个有关键字参数的查询函数（如 ``filter()`` 、``exclude()`` 和 ``get()`` ）可以
接受一个或多个 ``Q`` 对象作为位置参数（非命名参数）。如果你提供了多个 ``Q``
对象，则参数之间是”逻辑与“的关系。例如::

    Poll.objects.get(
        Q(question__startswith='Who'),
        Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
    )

... 相当于以下 SQL::

    SELECT * from polls WHERE question LIKE 'Who%'
        AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')

Lookup functions can mix the use of ``Q`` objects and keyword arguments. All
arguments provided to a lookup function (be they keyword arguments or ``Q``
objects) are "AND"ed together. However, if a ``Q`` object is provided, it must
precede the definition of any keyword arguments. For example::

    Poll.objects.get(
        Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
        question__startswith='Who')

... would be a valid query, equivalent to the previous example; but::

    # INVALID QUERY
    Poll.objects.get(
        question__startswith='Who',
        Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)))

... would not be valid.

.. seealso::

    The `OR lookups examples`_ in the Django unit tests show some possible uses
    of ``Q``.

    .. _OR lookups examples: http://code.djangoproject.com/browser/django/trunk/tests/modeltests/or_lookups/models.py

Comparing objects
=================

To compare two model instances, just use the standard Python comparison operator,
the double equals sign: ``==``. Behind the scenes, that compares the primary
key values of two models.

Using the ``Entry`` example above, the following two statements are equivalent::

    >>> some_entry == other_entry
    >>> some_entry.id == other_entry.id

If a model's primary key isn't called ``id``, no problem. Comparisons will
always use the primary key, whatever it's called. For example, if a model's
primary key field is called ``name``, these two statements are equivalent::

    >>> some_obj == other_obj
    >>> some_obj.name == other_obj.name

.. _topics-db-queries-delete:

Deleting objects
================

The delete method, conveniently, is named ``delete()``. This method immediately
deletes the object and has no return value. Example::

    e.delete()

You can also delete objects in bulk. Every ``QuerySet`` has a ``delete()``
method, which deletes all members of that ``QuerySet``.

For example, this deletes all ``Entry`` objects with a ``pub_date`` year of
2005::

    Entry.objects.filter(pub_date__year=2005).delete()

Keep in mind that this will, whenever possible, be executed purely in
SQL, and so the ``delete()`` methods of individual object instances
will not necessarily be called during the process. If you've provided
a custom ``delete()`` method on a model class and want to ensure that
it is called, you will need to "manually" delete instances of that
model (e.g., by iterating over a ``QuerySet`` and calling ``delete()``
on each object individually) rather than using the bulk ``delete()``
method of a ``QuerySet``.

When Django deletes an object, it emulates the behavior of the SQL
constraint ``ON DELETE CASCADE`` -- in other words, any objects which
had foreign keys pointing at the object to be deleted will be deleted
along with it. For example::

    b = Blog.objects.get(pk=1)
    # This will delete the Blog and all of its Entry objects.
    b.delete()

Note that ``delete()`` is the only ``QuerySet`` method that is not exposed on a
``Manager`` itself. This is a safety mechanism to prevent you from accidentally
requesting ``Entry.objects.delete()``, and deleting *all* the entries. If you
*do* want to delete all the objects, then you have to explicitly request a
complete query set::

    Entry.objects.all().delete()

.. _topics-db-queries-update:

Updating multiple objects at once
=================================

.. versionadded:: 1.0

Sometimes you want to set a field to a particular value for all the objects in
a ``QuerySet``. You can do this with the ``update()`` method. For example::

    # Update all the headlines with pub_date in 2007.
    Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')

You can only set non-relation fields and ``ForeignKey`` fields using this
method. To update a non-relation field, provide the new value as a constant.
To update ``ForeignKey`` fields, set the new value to be the new model
instance you want to point to. Example::

    >>> b = Blog.objects.get(pk=1)

    # Change every Entry so that it belongs to this Blog.
    >>> Entry.objects.all().update(blog=b)

The ``update()`` method is applied instantly and doesn't return anything
(similar to ``delete()``). The only restriction on the ``QuerySet`` that is
updated is that it can only access one database table, the model's main
table. So don't try to filter based on related fields or anything like that;
it won't work.

Be aware that the ``update()`` method is converted directly to an SQL
statement. It is a bulk operation for direct updates. It doesn't run any
``save()`` methods on your models, or emit the ``pre_save`` or ``post_save``
signals (which are a consequence of calling ``save()``). If you want to save
every item in a ``QuerySet`` and make sure that the ``save()`` method is
called on each instance, you don't need any special function to handle that.
Just loop over them and call ``save()``::

    for item in my_queryset:
        item.save()

.. versionadded:: 1.1

Calls to update can also use :ref:`F() objects <query-expressions>` to update
one field based on the value of another field in the model. This is especially
useful for incrementing counters based upon their current value. For example, to
increment the pingback count for every entry in the blog::

    >>> Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)

However, unlike ``F()`` objects in filter and exclude clauses, you can't
introduce joins when you use ``F()`` objects in an update -- you can only
reference fields local to the model being updated. If you attempt to introduce
a join with an ``F()`` object, a ``FieldError`` will be raised::

    # THIS WILL RAISE A FieldError
    >>> Entry.objects.update(headline=F('blog__name'))

Related objects
===============

When you define a relationship in a model (i.e., a ``ForeignKey``,
``OneToOneField``, or ``ManyToManyField``), instances of that model will have
a convenient API to access the related object(s).

Using the models at the top of this page, for example, an ``Entry`` object ``e``
can get its associated ``Blog`` object by accessing the ``blog`` attribute:
``e.blog``.

(Behind the scenes, this functionality is implemented by Python descriptors_.
This shouldn't really matter to you, but we point it out here for the curious.)

Django also creates API accessors for the "other" side of the relationship --
the link from the related model to the model that defines the relationship.
For example, a ``Blog`` object ``b`` has access to a list of all related
``Entry`` objects via the ``entry_set`` attribute: ``b.entry_set.all()``.

All examples in this section use the sample ``Blog``, ``Author`` and ``Entry``
models defined at the top of this page.

.. _descriptors: http://users.rcn.com/python/download/Descriptor.htm

One-to-many relationships
-------------------------

Forward
~~~~~~~

If a model has a ``ForeignKey``, instances of that model will have access to
the related (foreign) object via a simple attribute of the model.

Example::

    >>> e = Entry.objects.get(id=2)
    >>> e.blog # Returns the related Blog object.

You can get and set via a foreign-key attribute. As you may expect, changes to
the foreign key aren't saved to the database until you call ``save()``.
Example::

    >>> e = Entry.objects.get(id=2)
    >>> e.blog = some_blog
    >>> e.save()

If a ``ForeignKey`` field has ``null=True`` set (i.e., it allows ``NULL``
values), you can assign ``None`` to it. Example::

    >>> e = Entry.objects.get(id=2)
    >>> e.blog = None
    >>> e.save() # "UPDATE blog_entry SET blog_id = NULL ...;"

Forward access to one-to-many relationships is cached the first time the
related object is accessed. Subsequent accesses to the foreign key on the same
object instance are cached. Example::

    >>> e = Entry.objects.get(id=2)
    >>> print e.blog  # Hits the database to retrieve the associated Blog.
    >>> print e.blog  # Doesn't hit the database; uses cached version.

Note that the ``select_related()`` ``QuerySet`` method recursively prepopulates
the cache of all one-to-many relationships ahead of time. Example::

    >>> e = Entry.objects.select_related().get(id=2)
    >>> print e.blog  # Doesn't hit the database; uses cached version.
    >>> print e.blog  # Doesn't hit the database; uses cached version.

.. _backwards-related-objects:

Following relationships "backward"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If a model has a ``ForeignKey``, instances of the foreign-key model will have
access to a ``Manager`` that returns all instances of the first model. By
default, this ``Manager`` is named ``FOO_set``, where ``FOO`` is the source
model name, lowercased. This ``Manager`` returns ``QuerySets``, which can be
filtered and manipulated as described in the "Retrieving objects" section
above.

Example::

    >>> b = Blog.objects.get(id=1)
    >>> b.entry_set.all() # Returns all Entry objects related to Blog.

    # b.entry_set is a Manager that returns QuerySets.
    >>> b.entry_set.filter(headline__contains='Lennon')
    >>> b.entry_set.count()

You can override the ``FOO_set`` name by setting the ``related_name``
parameter in the ``ForeignKey()`` definition. For example, if the ``Entry``
model was altered to ``blog = ForeignKey(Blog, related_name='entries')``, the
above example code would look like this::

    >>> b = Blog.objects.get(id=1)
    >>> b.entries.all() # Returns all Entry objects related to Blog.

    # b.entries is a Manager that returns QuerySets.
    >>> b.entries.filter(headline__contains='Lennon')
    >>> b.entries.count()

You cannot access a reverse ``ForeignKey`` ``Manager`` from the class; it must
be accessed from an instance::

    >>> Blog.entry_set
    Traceback:
        ...
    AttributeError: "Manager must be accessed via instance".

In addition to the ``QuerySet`` methods defined in "Retrieving objects" above,
the ``ForeignKey`` ``Manager`` has additional methods used to handle the set of
related objects. A synopsis of each is below, and complete details can be found
in the :ref:`related objects reference <ref-models-relations>`.

``add(obj1, obj2, ...)``
    Adds the specified model objects to the related object set.

``create(**kwargs)``
    Creates a new object, saves it and puts it in the related object set.
    Returns the newly created object.

``remove(obj1, obj2, ...)``
    Removes the specified model objects from the related object set.

``clear()``
    Removes all objects from the related object set.

To assign the members of a related set in one fell swoop, just assign to it
from any iterable object. The iterable can contain object instances, or just
a list of primary key values. For example::

    b = Blog.objects.get(id=1)
    b.entry_set = [e1, e2]

In this example, ``e1`` and ``e2`` can be full Entry instances, or integer
primary key values.

If the ``clear()`` method is available, any pre-existing objects will be
removed from the ``entry_set`` before all objects in the iterable (in this
case, a list) are added to the set. If the ``clear()`` method is *not*
available, all objects in the iterable will be added without removing any
existing elements.

Each "reverse" operation described in this section has an immediate effect on
the database. Every addition, creation and deletion is immediately and
automatically saved to the database.

Many-to-many relationships
--------------------------

Both ends of a many-to-many relationship get automatic API access to the other
end. The API works just as a "backward" one-to-many relationship, above.

The only difference is in the attribute naming: The model that defines the
``ManyToManyField`` uses the attribute name of that field itself, whereas the
"reverse" model uses the lowercased model name of the original model, plus
``'_set'`` (just like reverse one-to-many relationships).

An example makes this easier to understand::

    e = Entry.objects.get(id=3)
    e.authors.all() # Returns all Author objects for this Entry.
    e.authors.count()
    e.authors.filter(name__contains='John')

    a = Author.objects.get(id=5)
    a.entry_set.all() # Returns all Entry objects for this Author.

Like ``ForeignKey``, ``ManyToManyField`` can specify ``related_name``. In the
above example, if the ``ManyToManyField`` in ``Entry`` had specified
``related_name='entries'``, then each ``Author`` instance would have an
``entries`` attribute instead of ``entry_set``.

One-to-one relationships
------------------------

One-to-one relationships are very similar to many-to-one relationships. If you
define a :class:`~django.db.models.OneToOneField` on your model, instances of
that model will have access to the related object via a simple attribute of the
model.

For example::

    class EntryDetail(models.Model):
        entry = models.OneToOneField(Entry)
        details = models.TextField()

    ed = EntryDetail.objects.get(id=2)
    ed.entry # Returns the related Entry object.

The difference comes in "reverse" queries. The related model in a one-to-one
relationship also has access to a :class:`~django.db.models.Manager` object, but
that :class:`~django.db.models.Manager` represents a single object, rather than
a collection of objects::

    e = Entry.objects.get(id=2)
    e.entrydetail # returns the related EntryDetail object

If no object has been assigned to this relationship, Django will raise
a ``DoesNotExist`` exception.

Instances can be assigned to the reverse relationship in the same way as
you would assign the forward relationship::

    e.entrydetail = ed

How are the backward relationships possible?
--------------------------------------------

Other object-relational mappers require you to define relationships on both
sides. The Django developers believe this is a violation of the DRY (Don't
Repeat Yourself) principle, so Django only requires you to define the
relationship on one end.

But how is this possible, given that a model class doesn't know which other
model classes are related to it until those other model classes are loaded?

The answer lies in the :setting:`INSTALLED_APPS` setting. The first time any model is
loaded, Django iterates over every model in :setting:`INSTALLED_APPS` and creates the
backward relationships in memory as needed. Essentially, one of the functions
of :setting:`INSTALLED_APPS` is to tell Django the entire model domain.

Queries over related objects
----------------------------

Queries involving related objects follow the same rules as queries involving
normal value fields. When specifying the value for a query to match, you may
use either an object instance itself, or the primary key value for the object.

For example, if you have a Blog object ``b`` with ``id=5``, the following
three queries would be identical::

    Entry.objects.filter(blog=b) # Query using object instance
    Entry.objects.filter(blog=b.id) # Query using id from instance
    Entry.objects.filter(blog=5) # Query using id directly

Falling back to raw SQL
=======================

If you find yourself needing to write an SQL query that is too complex for
Django's database-mapper to handle, you can fall back into raw-SQL statement
mode.

The preferred way to do this is by giving your model custom methods or custom
manager methods that execute queries. Although there's nothing in Django that
*requires* database queries to live in the model layer, this approach keeps all
your data-access logic in one place, which is smart from an code-organization
standpoint. For instructions, see :ref:`topics-db-sql`.

Finally, it's important to note that the Django database layer is merely an
interface to your database. You can access your database via other tools,
programming languages or database frameworks; there's nothing Django-specific
about your database.
