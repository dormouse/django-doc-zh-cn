.. _topics-db-managers:

========
管理器
========

.. currentmodule:: django.db.models

.. class:: Manager()

``管理器`` 是 Django 模型的数据库操作接口。每个 Django 应用中的模型至少有一个
``管理器`` 。

``管理器`` 类的工作方式在 :ref:`topics-db-queries` 有详细的描述。本文主要谈谈
自定义 ``管理器`` 。

.. _manager-names:

管理器名称
==========

缺省情况下， Django 为每个模型类添加一个名为 ``objects`` 的 ``管理器`` 。可是
如果你想把 ``objects`` 作为一个字段的名称或者你不想把 ``objects`` 作为
``管理器`` 的名称，那么你可以在模型的基础定义中重命名 ``管理器`` 的名称。重命名
的方法是在模型中定义一个 ``models.Manager()`` 类型的类属性。例如::

    from django.db import models

    class Person(models.Model):
        #...
        people = models.Manager()

上例中，如果使用 ``Person.objects`` 会引发一个 ``AttributeError`` 异常，但是
使用 ``Person.people.all()`` 则会返回一个所有 ``Person`` 对象的列表。

.. _custom-managers:

自定义管理器
===============

通过扩展基础 ``管理器`` 类可以在模型中使用自定义 ``管理器`` ，并初始化
``管理器`` 。

我们要使用自定义 ``管理器`` 有两个目的 ：增加额外的 ``管理器`` 方法和（或）修改
``管理器`` 返回的原始 ``查询集`` 。

增加额外的管理器方法
--------------------

增加额外的 ``管理器`` 方法是为模型增加“表级别”功能的首选方式。（要增加如作用于
模型对象中单个实例的“行级别”的功能请使用 :ref:`模型方法 <model-methods>` ，而
不要使用 ``管理器`` 方法。）

自定义 ``管理器`` 方法可以返回任何东西，不一定要返回一个 ``查询集`` 。

例如下面的自定义 ``管理器`` 提供一个 ``with_counts()`` 方法，这个方法返回一个
包含所有 ``OpinionPoll`` 的列表，每个列表中的对象都有一个 ``num_responses``
属性，这个属性代表一个合计数::

    class PollManager(models.Manager):
        def with_counts(self):
            from django.db import connection
            cursor = connection.cursor()
            cursor.execute("""
                SELECT p.id, p.question, p.poll_date, COUNT(*)
                FROM polls_opinionpoll p, polls_response r
                WHERE p.id = r.poll_id
                GROUP BY 1, 2, 3
                ORDER BY 3 DESC""")
            result_list = []
            for row in cursor.fetchall():
                p = self.model(id=row[0], question=row[1], poll_date=row[2])
                p.num_responses = row[3]
                result_list.append(p)
            return result_list

    class OpinionPoll(models.Model):
        question = models.CharField(max_length=200)
        poll_date = models.DateField()
        objects = PollManager()

    class Response(models.Model):
        poll = models.ForeignKey(Poll)
        person_name = models.CharField(max_length=50)
        response = models.TextField()

使用上例中的模型，你可以使用 ``OpinionPoll.objects.with_counts()`` 来返回带有
``num_responses`` 属性的 ``OpininPoll`` 对象列表。

另一个要注意的是 ``管理器`` 方法可以通过 ``self.model`` 来获得其所依附的模型类。

修改原始管理器查询集
--------------------

一个 ``管理器`` 的基础 ``查询集`` 返回系统中的所有对象。例如，使用这个模型::

    class Book(models.Model):
        title = models.CharField(max_length=100)
        author = models.CharField(max_length=50)

...语句 ``Book.objects.all()`` 会返回数据库中所有的书。

通过重载 ``Manager.get_query_set()`` 可以重载 ``管理器`` 的基础 ``查询集`` 。
``get_query_set()`` 应当返回一个符合你需求的 ``查询集`` 。

例如，以下模型有 *两个* ``管理器`` ，一个返回所有对象，另一个只返回作者为
Roald Dah1 的对象::

    # 首先定义管理器的子类。
    class DahlBookManager(models.Manager):
        def get_query_set(self):
            return super(DahlBookManager, self).get_query_set().filter(author='Roald Dahl')

    # 显式的把上面的子类安装到 Book 模型中。
    class Book(models.Model):
        title = models.CharField(max_length=100)
        author = models.CharField(max_length=50)

        objects = models.Manager() # The default manager.
        dahl_objects = DahlBookManager() # The Dahl-specific manager.

上例中， ``Book.objects.all()`` 会返回数据库中所有书，但是
``Book.dahl_objects.all()`` 只返回作者为Roald Dah1 的书。

当然，因为 ``get_query_set()`` 返回的是一个 ``查询集`` 对象，所以可以对这个对象
使用 ``filter()`` 、 ``exclude()`` 和所有其它 ``查询集`` 方法。以下语句都是合法
的::

    Book.dahl_objects.all()
    Book.dahl_objects.filter(title='Matilda')
    Book.dahl_objects.count()

这个例子也展示了一个有趣的技巧：在同一个模型中使用多个管理器。你可以为一个模型
附加任意多 ``Manager()`` 实例。 这是一个为模型定义常用“过滤器”的便捷方法。

例如::

    class MaleManager(models.Manager):
        def get_query_set(self):
            return super(MaleManager, self).get_query_set().filter(sex='M')

    class FemaleManager(models.Manager):
        def get_query_set(self):
            return super(FemaleManager, self).get_query_set().filter(sex='F')

    class Person(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        sex = models.CharField(max_length=1, choices=(('M', 'Male'), ('F', 'Female')))
        people = models.Manager()
        men = MaleManager()
        women = FemaleManager()

这个例子让你方便地使用 ``Person.men.all()`` 、 ``Person.women.all()`` 和
``Person.people.all()`` ，获得明确的结果。

如果你使用自定义 ``管理器`` 对象，那么要注意第一个 ``管理器`` （根据在模型
定义的顺序）有一个特殊的状态。 Django 把第一个 ``管理器`` 作为缺省的
``管理器`` ，并且 Django 的不同组成部分（虽然不是管理员程序）只使用模型的缺省
``管理器`` 。所以要仔细斟酌如何定义第一个 ``管理器`` ，以免在查询进无法获得正确
的结果。

.. _managers-for-related-objects:

使用管理器操作关联对象
~~~~~~~~~~~~~~~~~~~~~~

By default, Django uses an instance of a "plain" manager class when accessing
related objects (i.e. ``choice.poll``), not the default manager on the related
object. This is because Django needs to be able to retrieve the related
object, even if it would otherwise be filtered out (and hence be inaccessible)
by the default manager.

If the normal plain manager class (:class:`django.db.models.Manager`) is not
appropriate for your circumstances, you can force Django to use the same class
as the default manager for your model by setting the `use_for_related_fields`
attribute on the manager class. This is documented fully below_.

.. _below: manager-types_

.. _custom-managers-and-inheritance:

Custom managers and model inheritance
-------------------------------------

Class inheritance and model managers aren't quite a perfect match for each
other. Managers are often specific to the classes they are defined on and
inheriting them in subclasses isn't necessarily a good idea. Also, because the
first manager declared is the *default manager*, it is important to allow that
to be controlled. So here's how Django handles custom managers and
:ref:`model inheritance <model-inheritance>`:

    1. Managers defined on non-abstract base classes are *not* inherited by
       child classes. If you want to reuse a manager from a non-abstract base,
       redeclare it explicitly on the child class. These sorts of managers are
       likely to be fairly specific to the class they are defined on, so
       inheriting them can often lead to unexpected results (particularly as
       far as the default manager goes). Therefore, they aren't passed onto
       child classes.

    2. Managers from abstract base classes are always inherited by the child
       class, using Python's normal name resolution order (names on the child
       class override all others; then come names on the first parent class,
       and so on). Abstract base classes are designed to capture information
       and behavior that is common to their child classes. Defining common
       managers is an appropriate part of this common information.

    3. The default manager on a class is either the first manager declared on
       the class, if that exists, or the default manager of the first abstract
       base class in the parent hierarchy, if that exists. If no default
       manager is explicitly declared, Django's normal default manager is
       used.

These rules provide the necessary flexibility if you want to install a
collection of custom managers on a group of models, via an abstract base
class, but still customize the default manager. For example, suppose you have
this base class::

    class AbstractBase(models.Model):
        ...
        objects = CustomerManager()

        class Meta:
            abstract = True

If you use this directly in a subclass, ``objects`` will be the default
manager if you declare no managers in the base class::

    class ChildA(AbstractBase):
        ...
        # This class has CustomManager as the default manager.

If you want to inherit from ``AbstractBase``, but provide a different default
manager, you can provide the default manager on the child class::

    class ChildB(AbstractBase):
        ...
        # An explicit default manager.
        default_manager = OtherManager()

Here, ``default_manager`` is the default. The ``objects`` manager is
still available, since it's inherited. It just isn't used as the default.

Finally for this example, suppose you want to add extra managers to the child
class, but still use the default from ``AbstractBase``. You can't add the new
manager directly in the child class, as that would override the default and you would
have to also explicitly include all the managers from the abstract base class.
The solution is to put the extra managers in another base class and introduce
it into the inheritance hierarchy *after* the defaults::

    class ExtraManager(models.Model):
        extra_manager = OtherManager()

        class Meta:
            abstract = True

    class ChildC(AbstractBase, ExtraManager):
        ...
        # Default manager is CustomManager, but OtherManager is
        # also available via the "extra_manager" attribute.

.. _manager-types:

Controlling Automatic Manager Types
===================================

This document has already mentioned a couple of places where Django creates a
manager class for you: `default managers`_ and the "plain" manager used to
`access related objects`_. There are other places in the implementation of
Django where temporary plain managers are needed. Those automatically created
managers will normally be instances of the :class:`django.db.models.Manager`
class.

.. _default managers: manager-names_
.. _access related objects: managers-for-related-objects_

Throughout this section, we will use the term "automatic manager" to mean a
manager that Django creates for you -- either as a default manager on a model
with no managers, or to use temporarily when accessing related objects.

Sometimes this default class won't be the right choice. One example is in the
`django.contrib.gis` application that ships with Django itself. All `gis`
models must use a special manager class (``GeoManager``) because they need a
special queryset (``GeoQuerySet``) to be used for interacting with the
database.  It turns out that models which require a special manager like this
need to use the same manager class wherever an automatic manager is created.

Django provides a way for custom manager developers to say that their manager
class should be used for automatic managers whenever it is the default manager
on a model. This is done by setting the ``use_for_related_fields`` attribute on
the manager class::

    class MyManager(models.Manager):
        use_for_related_fields = True

        ...

If this attribute is set on the *default* manager for a model (only the
default manager is considered in these situations), Django will use that class
whenever it needs to automatically create a manager for the class.  Otherwise,
it will use :class:`django.db.models.Manager`.

.. admonition:: Historical Note

    Given the purpose for which it's used, the name of this attribute
    (``use_for_related_fields``) might seem a little odd. Originally, the
    attribute only controlled the type of manager used for related field
    access, which is where the name came from. As it became clear the concept
    was more broadly useful, the name hasn't been changed. This is primarily
    so that existing code will :ref:`continue to work <misc-api-stability>` in
    future Django versions.

Writing Correct Managers For Use In Automatic Manager Instances
---------------------------------------------------------------

As already suggested by the `django.contrib.gis` example, above, the
``use_for_related_fields`` feature is primarily for managers that need to
return a custom ``QuerySet`` subclass. In providing this functionality in your
manager, there are a couple of things to be remember and that's the topic of
this section.

Do not filter away any results in this type of manager subclass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One reason an automatic manager is used is to access objects that are related
to from some other model. In those situations, Django has to be able to see
all the objects for the model it is fetching, so that *anything* which is
referred to can be retrieved.

If you override the ``get_query_set()`` method and filter out any rows, Django
will return incorrect results. Don't do that. A manager that filters results
in ``get_query_set()`` is not appropriate for use as an automatic manager.

Set ``use_for_related_fields`` when you define the class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``use_for_related_fields`` attribute must be set on the manager *class*,
object not on an *instance* of the class. The earlier example shows the
correct way to set it, whereas the following will not work::

    # BAD: Incorrect code
    class MyManager(models.Manager):
        ...

    # Sets the attribute on an instance of MyManager. Django will
    # ignore this setting.
    mgr = MyManager()
    mgr.use_for_related_fields = True

    class MyModel(models.Model):
        ...
        objects = mgr

    # End of incorrect code.

You also shouldn't change the attribute on the class object after it has been
used in a model, since the attribute's value is processed when the model class
is created and not subsequently reread. Set the attribute on the manager class
when it is first defined, as in the initial example of this section and
everything will work smoothly.

