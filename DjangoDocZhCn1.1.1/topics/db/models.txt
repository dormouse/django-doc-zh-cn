.. _topics-db-models:

======
模型
======

.. module:: django.db.models

一个模型是你的数据的唯一的，精确的数据来源。它包含你所储存的数据的字段的本质和
和行为。通常每个模型对应一个数据库中的表。

基本上：

    * 每一个模型是一个由 :class:`django.db.models.Model` 继承而来的子类。

    * 模型的每一个属性对应一个数据库中的字段。

    * Django 会为你的模型自动生成数据库操作的 API ；详见 :ref:`topics-db-queries` 。

.. seealso::

    本文档有一篇名为 `模型例子的官方文档`_ 姐妹文档。（在 Django 的源代码中，
    这些例子在 ``tests/modeltests`` 目录下。）

    .. _`模型例子的官方文档`: http://www.djangoproject.com/documentation/models/

快速例子
========

以下例子定义了一个关于人（ ``Person`` ）的模型，包含姓（ ``first_name`` ）和名
``last_name`` 两个字段::

    from django.db import models

    class Person(models.Model):
        first_name = models.CharField(max_length=30)
        last_name = models.CharField(max_length=30)

``first_name`` 和 ``last_name`` 是模型的两个 字段_ ，每个字段定义为类的属性，
每个属性映射到一个数据库的列。

上例中的 ``Person`` 模型将会创建如下的数据库表：

.. code-block:: sql

    CREATE TABLE myapp_person (
        "id" serial NOT NULL PRIMARY KEY,
        "first_name" varchar(30) NOT NULL,
        "last_name" varchar(30) NOT NULL
    );

一些技术说明：

    * 数据库表的名称 ``myapp_person`` 是自动根据模型的元数据创建的，创建的方法
      可以重载。详见 :ref:`table-names` 。

    * 自动添加了一个 ``id`` 字段，这种行为也是可以重载的。参见
      :ref:`automatic-primary-key-fields` 。

    * 上例中的 ``CREATE TABLE`` SQL 使用的是 PostgreSQL 语法，但值得指出的是
      Django 会根据你的 :ref:`设置文件 <topics-settings>` 中设置的不同的数据库
      后台生成相应的 SQL 语句。

使用模型
============

一旦你定义好了你的模型，你得告诉 Django 你要 *使用* 这些模型。操作方法是编辑你
的设置文件，在 :setting:`INSTALLED_APPS` 设置中增加你的 ``models.py`` 。

例如，如果你的应用中模型放在 ``mysite.myapp.models`` 模块（由
:djadmin:`manage.py startapp <startapp>` 语句创建的包结构）中，那么
:setting:`INSTALLED_APPS` 应当包含如下内容::

    INSTALLED_APPS = (
        #...
        'mysite.myapp',
        #...
    )

每次向 :setting:`INSTALLED_APPS` 增加新的应用后，必须执行
:djadmin:`manage.py syncdb <syncdb>` 。

字段
======

一个模型最重要且不可或缺的部分就是数据库中定义的字段的列表。字段以类的属性的
方式定义。

例如::

    class Musician(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        instrument = models.CharField(max_length=100)

    class Album(models.Model):
        artist = models.ForeignKey(Musician)
        name = models.CharField(max_length=100)
        release_date = models.DateField()
        num_stars = models.IntegerField()

字段类型
-----------

你的模型中的每一个字段都应当是相应的 :class:`~django.db.models.Field` 类的实例。
Django 使用字段类来决定以下事项：

    * 数据库中的列的类型（如 ``INTEGER`` 、 ``VARCHAR`` ）。

    * 在 Django 管理站点中使用的控件（如 ``<input type="text">`` 、
      ``<select>`` ）。

    * 在 Django 管理站点和自动创建的表单中使用的数据验证方式。

Django 带有许多内置的字段类型，你可以在 :ref:`模型字段参考 <model-field-types>`
中找到完整的清单。如果内置的字段类型不够用，你可以方便地创建自定义的字段类型，
参见 :ref:`howto-custom-model-fields` 。

字段参数
-------------

每种字段都有一些特定的参数，参见 :ref:`模型字段参考 <model-field-types>` 。例如
:class:`~django.db.models.CharField` （包括其子类）用于数据中的 ``VARCHAR``
字段，这个类需要一个定义长度的 :attr:`~django.db.models.CharField.max_length`
参数。

还有一些通用于各种字段的参数，这些参数都是可选参数。详见 :ref:`参考
<common-model-field-options>` ，以下是这些参数中最常用参数的概述：

    :attr:`~Field.null`
        如果值为 ``True`` ，那么 Django 在数据库中储存空值，即 ``NULL`` 。
        缺省值为 ``False`` 。

    :attr:`~Field.blank`
        如果值为 ``True`` ，那么 field 允许为空。缺省值为 ``False`` 。

        注意这个参数与 :attr:`~Field.null` 是不同的。 :attr:`~Field.null`
        是与数据库相关的，而 :attr:`~Field.blank` 是与验证相关的。如果一个
        字段设置为 ``blank=True`` ，那么在 Django 的管理站点中允许输入项为空；
        如果设置为 ``blank=False`` ，那么这个字段为必填项。

    :attr:`~Field.choices`
        一个用于该字段的选择项的可迭代对象（例如 list 或 tuple ），由二元 tuple
        组成。如果有这个参数，那么 Django 管理站点中这个字段的输入会用一个选择
        框来代替文本框。

        一个 choices 列表例子如下::

            YEAR_IN_SCHOOL_CHOICES = (
                (u'FR', u'Freshman'),
                (u'SO', u'Sophomore'),
                (u'JR', u'Junior'),
                (u'SR', u'Senior'),
                (u'GR', u'Graduate'),
            )

        每个 tuple 第一个元素该选项是要储存的实际值，第二个元素管理站点或
        ModelChoiceField 中要显示的内容。通过使用 ``get_FOO_display`` 可以得到
        一个模型对象要显示的值。例如::

            from django.db import models

            class Person(models.Model):
                GENDER_CHOICES = (
                    (u'M', u'Male'),
                    (u'F', u'Female'),
                )
                name = models.CharField(max_length=60)
                gender = models.CharField(max_length=2, choices=GENDER_CHOICES)

        ::

            >>> p = Person(name="Fred Flinstone", gender="M")
            >>> p.save()
            >>> p.gender
            u'M'
            >>> p.get_gender_display()
            u'Male'

    :attr:`~Field.default`
        字段的缺省值。可以是一个值或一个可调用的对象。如果是一个可调用的对象，
        那么每次创建一个新对象时都会调用这个对象一次。

    :attr:`~Field.help_text`
        显示在对象的 admin 表单中的 field 下的额外的“帮助”文本。即使你不使用
        admin 表单，这个对于程序说明也有很大帮助。

    :attr:`~Field.primary_key`
        如果值为 ``True`` ，那么这个字段就是模型的主键。

        如果你不在任何一个字段定义 ``primary_key=True`` ，那么 Django 自动添加
        一个 :class:`IntegerField` 作为 primary key 。所以除非你想重载缺省的
        primary-key ，你不必在任何一个 field 设置 ``primary_key=True`` 。更多
        内容参见 :ref:`automatic-primary-key-fields` 。

    :attr:`~Field.unique`
        如果值为 ``True`` ，那么这个 field 在表中只能有唯一值。

重复一下，以上只是最常用的字段参数的简要说明。完整的细节参见 :ref:`常用模型字段
参数参考 <common-model-field-options>` 。

.. _automatic-primary-key-fields:

自动主键字段
------------

缺省情况下， Django 给每一个模型添加下面的字段::

    id = models.AutoField(primary_key=True)

这是一个自增主键。

如果你想要自定义主键，那么只要在你想要的字段上定义
:attr:`primary_key=True <Field.primary_key>` 就可以了。即如果 Django 发现你显式
的设置了 :attr:`Field.primary_key` ，那么就不会自动增加 ``id`` 列了。

每个模型都需要一个有 :attr:`primary_key=True <Field.primary_key>` 属性的字段。

.. _verbose-field-names:

详细字段名称
------------

除了 :class:`~django.db.models.ForeignKey` 、
:class:`~django.db.models.ManyToManyField` 和
:class:`~django.db.models.OneToOneField` 之外的第一个字段，第一个可选参数都是
详细名称。如果这个详细名称参数没有定义，那么 Django 会把通过把字段名称的下划线
转换为空格的方式自动创建字段的详细名称。

在下例中，详细名称为 ``"Person's first name"``::

    first_name = models.CharField("Person's first name", max_length=30)

在下例中，详细名称为 ``"first name"``::

    first_name = models.CharField(max_length=30)

:class:`~django.db.models.ForeignKey` 、
:class:`~django.db.models.ManyToManyField` 和
:class:`~django.db.models.OneToOneField` 的第一个参数是一个模型类，因此使用
:attr:`~Field.verbose_name` 关键字来定义详细名称::

    poll = models.ForeignKey(Poll, verbose_name="the related poll")
    sites = models.ManyToManyField(Site, verbose_name="list of sites")
    place = models.OneToOneField(Place, verbose_name="related place")

按照惯例， :attr:`~Field.verbose_name` 开头第一个字母是不大写的。 Django 会在
恰当的时候自动处理开头字母大写。

关系
----

显然，关系型数据库的关键是表与表之间的关系。 Django 提供了三种常用的的关系：
多对一、多对多、一对一。

多对一关系
~~~~~~~~~~

要定义多对一关系，请使用 :class:`~django.db.models.ForeignKey` 。使用方法与其他
:class:`~django.db.models.Field` 类型相同：把它作为你的模型的一个类属性。

:class:`~django.db.models.ForeignKey` 需要一个位置参数：相关联的类。

例如，一个 ``汽车（ Car ）`` 模型有一个 ``厂商（Manufacturer ）`` 字段。一个
``厂商`` 可以对应多个汽车，但一个 ``汽车`` 只有一个 ``厂商`` 。定义如下::

    class Manufacturer(models.Model):
        # ...

    class Car(models.Model):
        manufacturer = models.ForeignKey(Manufacturer)
        # ...

你也可以创建一个 :ref:`递归关系 <recursive-relationships>` （一个对象对于其本身
有多对一关系）和 :ref:`对应于未创建模型的关系 <lazy-relationships>` ，详见
:ref:`模型字段关系参考 <ref-foreignkey>` 。

只是作为一个建议，但不是规定，一个 :class:`~django.db.models.ForeignKey` 字段（
如上例中的 ``厂商`` ）的名称应当与相应模型的名称相同，并且小写。当然，
你也可以定义为任何名称，例如::

    class Car(models.Model):
        company_that_makes_it = models.ForeignKey(Manufacturer)
        # ...

.. seealso::

    更多例子参见 `多对一关系模型举例`_ 。

.. _多对一关系模型举例: http://www.djangoproject.com/documentation/models/many_to_one/

:class:`~django.db.models.ForeignKey` 也可以接受许多额外的参数，详见 :ref:`模型
字段参考 <foreign-key-arguments>` 。这些参数定义了关系如何工作，且都是可选参数。

多对多关系
~~~~~~~~~~

要定义多对多关系，请使用 :class:`~django.db.models.ManyToManyField` 。使用
方法与其他 :class:`~django.db.models.Field` 类型相同：把它作为你的模型的一个
类属性。

:class:`~django.db.models.ManyToManyField` 需要一个位置参数：相关联的类。

例如，假设一个 ``比萨饼（ Pizza ）`` 有多个 ``调料（ Topping ）`` 对象，一个
``调料`` 对应多个比萨饼并且每个 ``比萨饼`` 有多个调料。定义如下::

    class Topping(models.Model):
        # ...

    class Pizza(models.Model):
        # ...
        toppings = models.ManyToManyField(Topping)

就象 :class:`~django.db.models.ForeignKey` 一样，你也可以创建
:ref:`递归关系 <recursive-relationships>` （一个对象对于其本身
有多对一关系）和 :ref:`对应于未创建模型的关系 <lazy-relationships>` ，详见
:ref:`模型字段关系参考 <ref-manytomany>` 。

只是作为一个建议，但不是规定，一个
:class:`~django.db.models.ManyToManyField` （如上例中的 ``调料`` ）的名称应当是
相关模型对象的复数。

不管在哪个模型中使用 :class:`~django.db.models.ManyToManyField` ，但是你只需要
在一个模型中使用，不需要两个模型中都使用。

通常，如果你想使用管理站点，那么 :class:`~django.db.models.ManyToManyField`
实例应当在准备中管理站点中编辑的对象中使用。在上例中， ``调料`` 在
``比萨饼`` 中定义（比 ``调料`` 有一个关于 ``比萨饼`` 的
:class:`~django.db.models.ManyToManyField` 好）。因为一个比萨饼有多种调料比一个
调料有多个比萨饼要自然一点。根据上例中的定义，在 ``比萨饼`` 管理表单中
用户可以选择不同的调料。

.. seealso::

    更多例子参见 `多对多关系模型举例`_ 。

.. _多对多关系模型举例: http://www.djangoproject.com/documentation/models/many_to_many/

:class:`~django.db.models.ManyToManyField` 也可以接受许多额外的参数，详见 :ref:`模型
字段参考 <manytomany-arguments>` 。这些参数定义了关系如何工作，且都是可选参数。

.. _intermediary-manytomany:

多对多关系上的扩展字段
~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

当你处理如上例中的比萨饼和调料这种简单的多对多关系时，标准的
:class:`~django.db.models.ManyToManyField` 就够用了。然而，有时你需要处理两个
模型之间的相关联的数据，标准的类就不够用了。

例如，假设有一个管理音乐团体和音乐家的应用程序。这个程序中有一个人与其所属团体
之间的关系，所以你可以使用一个 :class:`~django.db.models.ManyToManyField` 来
表现这种关系。然而，你可能要搜集一个成员的许多信息，如成员加入团体的时间。

对于这种情况，在 Django 中你可以定义中介模型专门用于处理关系的模型。你可以把
扩展的字段放在中介模型中。中介模型是通过使用
:class:`~django.db.models.ManyToManyField` 的
:attr:`through <ManyToManyField.through>` 属性来定义的。对于上述的音乐家的例子，
代码如下::

    class Person(models.Model):
        name = models.CharField(max_length=128)

        def __unicode__(self):
            return self.name

    class Group(models.Model):
        name = models.CharField(max_length=128)
        members = models.ManyToManyField(Person, through='Membership')

        def __unicode__(self):
            return self.name

    class Membership(models.Model):
        person = models.ForeignKey(Person)
        group = models.ForeignKey(Group)
        date_joined = models.DateField()
        invite_reason = models.CharField(max_length=64)

在你的中介模型中，你必须把多对多关系中的两个模型显式定义为外键，以明确相关模型
是如何关联的。

中介模型有一些规定：

    * 你的中模型中必须有且仅有一个目标模型外键（如上例中的 ``Person`` ）。如果
      定义了多个，会产生验证错误。

    * 你的中模型中必须有且仅有一个来源模型外键（如上例中的 ``Group`` ）。如果
      定义了多个，会产生验证错误。

    * 唯一的例外是，当一个模型通过中介模型来表现相对于自身的多对多关系时，两个
      外键可以指向同一个模型，但是这两个外键会被当作多对多关系的两面来对待。

    * 当使用中介模型来表现相对于自身的多对多关系时，你 *必须* 使用
      :attr:`symmetrical=False <ManyToManyField.symmetrical>` （参见
      :ref:`模型字段参考 <manytomany-arguments>` ）。

现在你已经通过使用中介模型（本例中的 ``Membership`` ）来表现
:class:`~django.db.models.ManyToManyField` ，下面通过创建中介模型的实例来创建
一些多对多关系::

    >>> ringo = Person.objects.create(name="Ringo Starr")
    >>> paul = Person.objects.create(name="Paul McCartney")
    >>> beatles = Group.objects.create(name="The Beatles")
    >>> m1 = Membership(person=ringo, group=beatles,
    ...     date_joined=date(1962, 8, 16),
    ...     invite_reason= "Needed a new drummer.")
    >>> m1.save()
    >>> beatles.members.all()
    [<Person: Ringo Starr>]
    >>> ringo.group_set.all()
    [<Group: The Beatles>]
    >>> m2 = Membership.objects.create(person=paul, group=beatles,
    ...     date_joined=date(1960, 8, 1),
    ...     invite_reason= "Wanted to form a band.")
    >>> beatles.members.all()
    [<Person: Ringo Starr>, <Person: Paul McCartney>]

和一般多对多关系字段不同，你 *不能* 使用 ``add`` 、 ``create`` 或赋值（例如：
``beatles.members = [...]`` ）来创建关系::

    # 这样是不对的
    >>> beatles.members.add(john)
    # 这样也不对
    >>> beatles.members.create(name="George Harrison")
    # 这样还是不对
    >>> beatles.members = [john, paul, ringo, george]

为什么？因为你不能只创建 ``Person`` 和 ``Group`` 之间的关系，你还必须去定义
``Membership`` 模型所需要的全部细节内容。而简单的 ``add`` 、 ``create`` 和赋值
无法做到这点。所以使用中介模型不能这样创建关系，只能通过创建中介模型的实例来
创建关系。

同理， ``remove`` 方法也不可以。然而 ``clear()`` 方法可以用于移除一个实例的所有
多对多关系::

    # Beatles 中所有关系都被清除
    >>> beatles.members.clear()

一旦你通过创建中介模型实例的方式创建了关系，就可以进行查询了。和一般多对多关系
一样，你可以使用多对多关系模型的属性来查询::

    # 查找所有包含名字以 'Paul' 开头的组员的组
    >>> Group.objects.filter(members__name__startswith='Paul')
    [<Group: The Beatles>]

当你使用中介模型时，你还可以通过相关模型的属性来查询::

    # 查找所有 Beatles 的 1961 年 1 月 1 日以后加入的成员
    >>> Person.objects.filter(
    ...     group__name='The Beatles',
    ...     membership__date_joined__gt=date(1961,1,1))
    [<Person: Ringo Starr]


一对一关系
~~~~~~~~~~

要定义一对一关系，请使用 :class:`~django.db.models.OneToOneField` 。使用
方法与其他 :class:`~django.db.models.Field` 类型相同：把它作为你的模型的一个
类属性。

这种关系常用于通过主键来扩展相关的对象。

:class:`~django.db.models.OneToOneField` 需要一个位置参数：相关联的类。

例如，假设你要建立一个“场所”数据库，你会在数据库中创建一些常用的内容，如地址、
电话号码等等。接着，假设你要创建一个基于场所的餐厅数据库，那么你就不必重复创建
场所数据库中已有的内容，而只要在 ``Restaurant`` 模型中建立一个与 ``Place`` 关联
的 :class:`~django.db.models.OneToOneField` 就可以了。因为餐厅是场所的一种。
实际上，要处理这种情况，最好使用 :ref:`继承 <model-inheritance>` 。继承暗含了一
对一关系。

就象 :class:`~django.db.models.ForeignKey` 一样，你也可以创建
:ref:`递归关系 <recursive-relationships>` （一个对象对于其本身有多对一关系）和
:ref:`对应于未创建模型的关系 <lazy-relationships>` ，详见
:ref:`模型字段关系参考 <ref-onetoone>` 。

.. seealso::

    更多例子参见 `一对一关系模型举例`_ 。

.. _一对一关系模型举例: http://www.djangoproject.com/documentation/models/one_to_one/

.. versionadded:: 1.0

:class:`~django.db.models.OneToOneField` 字段还可以接受一个 :ref:`模型字段参考
<ref-onetoone>` 中说明的可选参数。

:class:`~django.db.models.OneToOneField` 类通常自动成为一个模型的主键。但是你也
可以通过 :attr:`~django.db.models.Field.primary_key` 参数来手动设置。现在也可以
在一个模型中使用多个 :class:`~django.db.models.OneToOneField` 。

使用不同文件中的模型
--------------------

关联不同应用之中模型是非常方便的。只要在模型的开头导入要关联的模型，就可以引用
在本模型中引用了。例如::

    from mysite.geography.models import ZipCode

    class Restaurant(models.Model):
        # ...
        zip_code = models.ForeignKey(ZipCode)

字段名限制
----------

Django 中字段名只有两个限制：

    1. 字段名不能是 Python 保留字，否则会引发 Python 语法错误。例如::

           class Example(models.Model):
               pass = models.IntegerField() # 'pass' 是一个保留字！

    2. 字段名不能包含一个以上的下划线，这是 Django 的查询搜索语法所决定的。
       例如::

           class Example(models.Model):
               foo__bar = models.IntegerField() # 'foo__bar' 有两个下划线！

以上限制是可以绕过的，因为字段名称与数据库中的列名称不必相同。参见
:attr:`~Field.db_column` 选项。

SQL 保留字，如 ``join`` 、 ``where`` 或 ``select`` ， *允许* 作为模型字段的名称。
因为 Django 在背后生成的 SQL 查询语句中对所有数据库表名和列名都进行了转义，这些
SQL 语句针对特定的数据库使用引号语法。

自定义字段类型
------------------

.. versionadded:: 1.0

如果现有的模型字段类型无法满足你的需要，或者你想要使用冷门的数据库列类型，那么
你可以创建你自己的字段类。详见 :ref:`howto-custom-model-fields` 。

.. _meta-options:

Meta options
============

Give your model metadata by using an inner ``class Meta``, like so::

    class Ox(models.Model):
        horn_length = models.IntegerField()

        class Meta:
            ordering = ["horn_length"]
            verbose_name_plural = "oxen"

Model metadata is "anything that's not a field", such as ordering options
(:attr:`~Options.ordering`), database table name (:attr:`~Options.db_table`), or
human-readable singular and plural names (:attr:`~Options.verbose_name` and
:attr:`~Options.verbose_name_plural`). None are required, and adding ``class
Meta`` to a model is completely optional.

A complete list of all possible ``Meta`` options can be found in the :ref:`model
option reference <ref-models-options>`.

.. _model-methods:

Model methods
=============

Define custom methods on a model to add custom "row-level" functionality to your
objects. Whereas :class:`~django.db.models.Manager` methods are intended to do
"table-wide" things, model methods should act on a particular model instance.

This is a valuable technique for keeping business logic in one place -- the
model.

For example, this model has a few custom methods::

    from django.contrib.localflavor.us.models import USStateField

    class Person(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        birth_date = models.DateField()
        address = models.CharField(max_length=100)
        city = models.CharField(max_length=50)
        state = USStateField() # Yes, this is America-centric...

        def baby_boomer_status(self):
            "Returns the person's baby-boomer status."
            import datetime
            if datetime.date(1945, 8, 1) <= self.birth_date <= datetime.date(1964, 12, 31):
                return "Baby boomer"
            if self.birth_date < datetime.date(1945, 8, 1):
                return "Pre-boomer"
            return "Post-boomer"

        def is_midwestern(self):
            "Returns True if this person is from the Midwest."
            return self.state in ('IL', 'WI', 'MI', 'IN', 'OH', 'IA', 'MO')

        def _get_full_name(self):
            "Returns the person's full name."
            return '%s %s' % (self.first_name, self.last_name)
        full_name = property(_get_full_name)

The last method in this example is a :term:`property`. `Read more about
properties`_.

.. _Read more about properties: http://www.python.org/download/releases/2.2/descrintro/#property

The :ref:`model instance reference <ref-models-instances>` has a complete list
of :ref:`methods automatically given to each model <model-instance-methods>`.
You can override most of these -- see `overriding predefined model methods`_,
below -- but there are a couple that you'll almost always want to define:

    :meth:`~Model.__unicode__`
        A Python "magic method" that returns a unicode "representation" of any
        object. This is what Python and Django will use whenever a model
        instance needs to be coerced and displayed as a plain string. Most
        notably, this happens when you display an object in an interactive
        console or in the admin.

        You'll always want to define this method; the default isn't very helpful
        at all.

    :meth:`~Model.get_absolute_url`
        This tells Django how to calculate the URL for an object. Django uses
        this in its admin interface, and any time it needs to figure out a URL
        for an object.

        Any object that has a URL that uniquely identifies it should define this
        method.

Overriding predefined model methods
-----------------------------------

There's another set of :ref:`model methods <model-instance-methods>` that
encapsulate a bunch of database behavior that you'll want to customize. In
particular you'll often want to change the way :meth:`~Model.save` and
:meth:`~Model.delete` work.

You're free to override these methods (and any other model method) to alter
behavior.

A classic use-case for overriding the built-in methods is if you want something
to happen whenever you save an object. For example (see
:meth:`~Model.save` for documentation of the parameters it accepts)::

    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def save(self, force_insert=False, force_update=False):
            do_something()
            super(Blog, self).save(force_insert, force_update) # Call the "real" save() method.
            do_something_else()

You can also prevent saving::

    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def save(self, force_insert=False, force_update=False):
            if self.name == "Yoko Ono's blog":
                return # Yoko shall never have her own blog!
            else:
                super(Blog, self).save(force_insert, force_update) # Call the "real" save() method.

It's important to remember to call the superclass method -- that's that
``super(Blog, self).save()`` business -- to ensure that the object still gets
saved into the database. If you forget to call the superclass method, the
default behavior won't happen and the database won't get touched.

Executing custom SQL
--------------------

Another common pattern is writing custom SQL statements in model methods and
module-level methods. For more details on using raw SQL, see the documentation
on :ref:`using raw SQL<topics-db-sql>`.

.. _model-inheritance:

Model inheritance
=================

.. versionadded:: 1.0

Model inheritance in Django works almost identically to the way normal
class inheritance works in Python. The only decision you have to make
is whether you want the parent models to be models in their own right
(with their own database tables), or if the parents are just holders
of common information that will only be visible through the child
models.

There are three styles of inheritance that are possible in Django.

 1. Often, you will just want to use the parent class to hold information that
    you don't want to have to type out for each child model. This class isn't
    going to ever be used in isolation, so :ref:`abstract-base-classes` are
    what you're after.
 2. If you're subclassing an existing model (perhaps something from another
    application entirely) and want each model to have its own database table,
    :ref:`multi-table-inheritance` is the way to go.
 3. Finally, if you only want to modify the Python-level behaviour of a model,
    without changing the models fields in any way, you can use
    :ref:`proxy-models`.

.. _abstract-base-classes:

Abstract base classes
---------------------

Abstract base classes are useful when you want to put some common
information into a number of other models. You write your base class
and put ``abstract=True`` in the :ref:`Meta <meta-options>`
class. This model will then not be used to create any database
table. Instead, when it is used as a base class for other models, its
fields will be added to those of the child class. It is an error to
have fields in the abstract base class with the same name as those in
the child (and Django will raise an exception).

An example::

    class CommonInfo(models.Model):
        name = models.CharField(max_length=100)
        age = models.PositiveIntegerField()

        class Meta:
            abstract = True

    class Student(CommonInfo):
        home_group = models.CharField(max_length=5)

The ``Student`` model will have three fields: ``name``, ``age`` and
``home_group``. The ``CommonInfo`` model cannot be used as a normal Django
model, since it is an abstract base class. It does not generate a database
table or have a manager, and cannot be instantiated or saved directly.

For many uses, this type of model inheritance will be exactly what you want.
It provides a way to factor out common information at the Python level, whilst
still only creating one database table per child model at the database level.

``Meta`` inheritance
~~~~~~~~~~~~~~~~~~~~

When an abstract base class is created, Django makes any :ref:`Meta <meta-options>`
inner class you declared in the base class available as an
attribute. If a child class does not declare its own :ref:`Meta <meta-options>`
class, it will inherit the parent's :ref:`Meta <meta-options>`. If the child wants to
extend the parent's :ref:`Meta <meta-options>` class, it can subclass it. For example::

    class CommonInfo(models.Model):
        ...
        class Meta:
            abstract = True
            ordering = ['name']

    class Student(CommonInfo):
        ...
        class Meta(CommonInfo.Meta):
            db_table = 'student_info'

Django does make one adjustment to the :ref:`Meta <meta-options>` class of an abstract base
class: before installing the :ref:`Meta <meta-options>` attribute, it sets ``abstract=False``.
This means that children of abstract base classes don't automatically become
abstract classes themselves. Of course, you can make an abstract base class
that inherits from another abstract base class. You just need to remember to
explicitly set ``abstract=True`` each time.

Some attributes won't make sense to include in the :ref:`Meta <meta-options>` class of an
abstract base class. For example, including ``db_table`` would mean that all
the child classes (the ones that don't specify their own :ref:`Meta <meta-options>`) would use
the same database table, which is almost certainly not what you want.

.. _abstract-related-name:

Be careful with ``related_name``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you are using the :attr:`~django.db.models.ForeignKey.related_name` attribute on a ``ForeignKey`` or
``ManyToManyField``, you must always specify a *unique* reverse name for the
field. This would normally cause a problem in abstract base classes, since the
fields on this class are included into each of the child classes, with exactly
the same values for the attributes (including :attr:`~django.db.models.ForeignKey.related_name`) each time.

To work around this problem, when you are using :attr:`~django.db.models.ForeignKey.related_name` in an
abstract base class (only), part of the name should be the string
``'%(class)s'``. This is replaced by the lower-cased name of the child class
that the field is used in. Since each class has a different name, each related
name will end up being different. For example::

    class Base(models.Model):
        m2m = models.ManyToManyField(OtherModel, related_name="%(class)s_related")

        class Meta:
            abstract = True

    class ChildA(Base):
        pass

    class ChildB(Base):
        pass

The reverse name of the ``ChildA.m2m`` field will be ``childa_related``,
whilst the reverse name of the ``ChildB.m2m`` field will be
``childb_related``. It is up to you how you use the ``'%(class)s'`` portion to
construct your related name, but if you forget to use it, Django will raise
errors when you validate your models (or run :djadmin:`syncdb`).

If you don't specify a :attr:`~django.db.models.ForeignKey.related_name` attribute for a field in an
abstract base class, the default reverse name will be the name of the
child class followed by ``'_set'``, just as it normally would be if
you'd declared the field directly on the child class. For example, in
the above code, if the :attr:`~django.db.models.ForeignKey.related_name` attribute was omitted, the
reverse name for the ``m2m`` field would be ``childa_set`` in the
``ChildA`` case and ``childb_set`` for the ``ChildB`` field.

.. _multi-table-inheritance:

Multi-table inheritance
-----------------------

The second type of model inheritance supported by Django is when each model in
the hierarchy is a model all by itself. Each model corresponds to its own
database table and can be queried and created individually. The inheritance
relationship introduces links between the child model and each of its parents
(via an automatically-created :class:`~django.db.models.fields.OneToOneField`).
For example::

    class Place(models.Model):
        name = models.CharField(max_length=50)
        address = models.CharField(max_length=80)

    class Restaurant(Place):
        serves_hot_dogs = models.BooleanField()
        serves_pizza = models.BooleanField()

All of the fields of ``Place`` will also be available in ``Restaurant``,
although the data will reside in a different database table. So these are both
possible::

    >>> Place.objects.filter(name="Bob's Cafe")
    >>> Restaurant.objects.filter(name="Bob's Cafe")

If you have a ``Place`` that is also a ``Restaurant``, you can get from the
``Place`` object to the ``Restaurant`` object by using the lower-case version
of the model name::

    >>> p = Place.objects.filter(name="Bob's Cafe")
    # If Bob's Cafe is a Restaurant object, this will give the child class:
    >>> p.restaurant
    <Restaurant: ...>

However, if ``p`` in the above example was *not* a ``Restaurant`` (it had been
created directly as a ``Place`` object or was the parent of some other class),
referring to ``p.restaurant`` would raise a Restaurant.DoesNotExist exception.

``Meta`` and multi-table inheritance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the multi-table inheritance situation, it doesn't make sense for a child
class to inherit from its parent's :ref:`Meta <meta-options>` class. All the :ref:`Meta <meta-options>` options
have already been applied to the parent class and applying them again would
normally only lead to contradictory behavior (this is in contrast with the
abstract base class case, where the base class doesn't exist in its own
right).

So a child model does not have access to its parent's :ref:`Meta
<meta-options>` class. However, there are a few limited cases where the child
inherits behavior from the parent: if the child does not specify an
:attr:`django.db.models.Options.ordering` attribute or a
:attr:`django.db.models.Options.get_latest_by` attribute, it will inherit
these from its parent.

If the parent has an ordering and you don't want the child to have any natural
ordering, you can explicitly disable it::

    class ChildModel(ParentModel):
        ...
        class Meta:
            # Remove parent's ordering effect
            ordering = []

Inheritance and reverse relations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Because multi-table inheritance uses an implicit
:class:`~django.db.models.fields.OneToOneField` to link the child and
the parent, it's possible to move from the parent down to the child,
as in the above example. However, this uses up the name that is the
default :attr:`~django.db.models.ForeignKey.related_name` value for
:class:`django.db.models.fields.ForeignKey` and
:class:`django.db.models.fields.ManyToManyField` relations.  If you
are putting those types of relations on a subclass of another model,
you **must** specify the
:attr:`~django.db.models.ForeignKey.related_name` attribute on each
such field. If you forget, Django will raise an error when you run
:djadmin:`validate` or :djadmin:`syncdb`.

For example, using the above ``Place`` class again, let's create another
subclass with a :class:`~django.db.models.fields.ManyToManyField`::

    class Supplier(Place):
        # Must specify related_name on all relations.
        customers = models.ManyToManyField(Restaurant, related_name='provider')


Specifying the parent link field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As mentioned, Django will automatically create a
:class:`~django.db.models.fields.OneToOneField` linking your child
class back any non-abstract parent models. If you want to control the
name of the attribute linking back to the parent, you can create your
own :class:`~django.db.models.fields.OneToOneField` and set
:attr:`parent_link=True <django.db.models.fields.OneToOneField.parent_link>`
to indicate that your field is the link back to the parent class.

.. _proxy-models:

Proxy models
------------

.. versionadded:: 1.1

When using :ref:`multi-table inheritance <multi-table-inheritance>`, a new
database table is created for each subclass of a model. This is usually the
desired behavior, since the subclass needs a place to store any additional
data fields that are not present on the base class. Sometimes, however, you
only want to change the Python behavior of a model -- perhaps to change the
default manager, or add a new method.

This is what proxy model inheritance is for: creating a *proxy* for the
original model. You can create, delete and update instances of the proxy model
and all the data will be saved as if you were using the original (non-proxied)
model. The difference is that you can change things like the default model
ordering or the default manager in the proxy, without having to alter the
original.

Proxy models are declared like normal models. You tell Django that it's a
proxy model by setting the :attr:`~django.db.models.Options.proxy` attribute of
the ``Meta`` class to ``True``.

For example, suppose you want to add a method to the standard ``User`` model
that will be used in your templates. You can do it like this::

    from django.contrib.auth.models import User

    class MyUser(User):
        class Meta:
            proxy = True

        def do_something(self):
            ...

The ``MyUser`` class operates on the same database table as its parent
``User`` class. In particular, any new instances of ``User`` will also be
accessible through ``MyUser``, and vice-versa::

    >>> u = User.objects.create(username="foobar")
    >>> MyUser.objects.get(username="foobar")
    <MyUser: foobar>

You could also use a proxy model to define a different default ordering on a
model. The standard ``User`` model has no ordering defined on it
(intentionally; sorting is expensive and we don't want to do it all the time
when we fetch users). You might want to regularly order by the ``username``
attribute when you use the proxy. This is easy::

    class OrderedUser(User):
        class Meta:
            ordering = ["username"]
            proxy = True

Now normal ``User`` queries will be unorderd and ``OrderedUser`` queries will
be ordered by ``username``.

Querysets still return the model that was requested
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There is no way to have Django return, say, a ``MyUser`` object whenever you
query for ``User`` objects. A queryset for ``User`` objects will return those
types of objects. The whole point of proxy objects is that code relying on the
original ``User`` will use those and your own code can use the extensions you
included (that no other code is relying on anyway). It is not a way to replace
the ``User`` (or any other) model everywhere with something of your own
creation.

Base class restrictions
~~~~~~~~~~~~~~~~~~~~~~~

A proxy model must inherit from exactly one non-abstract model class. You
can't inherit from multiple non-abstract models as the proxy model doesn't
provide any connection between the rows in the different database tables. A
proxy model can inherit from any number of abstract model classes, providing
they do *not* define any model fields.

Proxy models inherit any ``Meta`` options that they don't define from their
non-abstract model parent (the model they are proxying for).

Proxy model managers
~~~~~~~~~~~~~~~~~~~~

If you don't specify any model managers on a proxy model, it inherits the
managers from its model parents. If you define a manager on the proxy model,
it will become the default, although any managers defined on the parent
classes will still be available.

Continuing our example from above, you could change the default manager used
when you query the ``User`` model like this::

    class NewManager(models.Manager):
        ...

    class MyUser(User):
        objects = NewManager()

        class Meta:
            proxy = True

If you wanted to add a new manager to the Proxy, without replacing the
existing default, you can use the techniques described in the :ref:`custom
manager <custom-managers-and-inheritance>` documentation: create a base class
containing the new managers and inherit that after the primary base class::

    # Create an abstract class for the new manager.
    class ExtraManagers(models.Model):
        secondary = NewManager()

        class Meta:
            abstract = True

    class MyUser(User, ExtraManagers):
        class Meta:
            proxy = True

You probably won't need to do this very often, but, when you do, it's
possible.

.. _proxy-vs-unmanaged-models:

Differences between proxy inheritance and  unmanaged models
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Proxy model inheritance might look fairly similar to creating an unmanaged
model, using the :attr:`~django.db.models.Options.managed` attribute on a
model's ``Meta`` class. The two alternatives are not quite the same and it's
worth considering which one you should use.

One difference is that you can (and, in fact, must unless you want an empty
model) specify model fields on models with ``Meta.managed=False``. You could,
with careful setting of :attr:`Meta.db_table
<django.db.models.Options.db_table>` create an unmanaged model that shadowed
an existing model and add Python methods to it. However, that would be very
repetitive and fragile as you need to keep both copies synchronized if you
make any changes.

The other difference that is more important for proxy models, is how model
managers are handled. Proxy models are intended to behave exactly like the
model they are proxying for. So they inherit the parent model's managers,
including the default manager. In the normal multi-table model inheritance
case, children do not inherit managers from their parents as the custom
managers aren't always appropriate when extra fields are involved. The
:ref:`manager documentation <custom-managers-and-inheritance>` has more
details about this latter case.

When these two features were implemented, attempts were made to squash them
into a single option. It turned out that interactions with inheritance, in
general, and managers, in particular, made the API very complicated and
potentially difficult to understand and use. It turned out that two options
were needed in any case, so the current separation arose.

So, the general rules are:

    1. If you are mirroring an existing model or database table and don't want
       all the original database table columns, use ``Meta.managed=False``.
       That option is normally useful for modeling database views and tables
       not under the control of Django.
    2. If you are wanting to change the Python-only behavior of a model, but
       keep all the same fields as in the original, use ``Meta.proxy=True``.
       This sets things up so that the proxy model is an exact copy of the
       storage structure of the original model when data is saved.

Multiple inheritance
--------------------

Just as with Python's subclassing, it's possible for a Django model to inherit
from multiple parent models. Keep in mind that normal Python name resolution
rules apply. The first base class that a particular name (e.g. :ref:`Meta
<meta-options>`) appears in will be the one that is used; for example, this
means that if multiple parents contain a :ref:`Meta <meta-options>` class,
only the first one is going to be used, and all others will be ignored.

Generally, you won't need to inherit from multiple parents. The main use-case
where this is useful is for "mix-in" classes: adding a particular extra
field or method to every class that inherits the mix-in. Try to keep your
inheritance hierarchies as simple and straightforward as possible so that you
won't have to struggle to work out where a particular piece of information is
coming from.

Field name "hiding" is not permitted
-------------------------------------

In normal Python class inheritance, it is permissible for a child class to
override any attribute from the parent class. In Django, this is not permitted
for attributes that are :class:`~django.db.models.fields.Field` instances (at
least, not at the moment). If a base class has a field called ``author``, you
cannot create another model field called ``author`` in any class that inherits
from that base class.

Overriding fields in a parent model leads to difficulties in areas such as
initialising new instances (specifying which field is being intialised in
``Model.__init__``) and serialization. These are features which normal Python
class inheritance doesn't have to deal with in quite the same way, so the
difference between Django model inheritance and Python class inheritance isn't
merely arbitrary.

This restriction only applies to attributes which are
:class:`~django.db.models.fields.Field` instances. Normal Python attributes
can be overridden if you wish. It also only applies to the name of the
attribute as Python sees it: if you are manually specifying the database
column name, you can have the same column name appearing in both a child and
an ancestor model for multi-table inheritance (they are columns in two
different database tables).

Django will raise a ``FieldError`` exception if you override any model field
in any ancestor model.

