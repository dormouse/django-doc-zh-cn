.. _topics-auth:

=============================
Django 中的用户认证
=============================

.. module:: django.contrib.auth
   :synopsis: Django's authentication framework.

Django 自带一个用户认证系统，这个系统处理用户帐户、组、权限和基于 cookie 的
会话。本文说明这个系统是如何工作的。

概览
====

认证系统由以下部分组成：

    * 用户
    * 权限：控制用户进否可以执行某项任务的二进制（是/否）标志。
    * 组：一种为多个用户加上标签和权限的常用方式。
    * 消息：一种为指定用户生成简单消息队列的方式。

安装
====

认证系统打包在 Django 的 ``django.contrib.auth`` 应用中，安装它有以下步骤：

    1. 把 ``'django.contrib.auth'`` 和 ``'django.contrib.contenttypes'`` 放到
       :setting:`INSTALLED_APPS` 设置中。（ :mod:`django.contrib.auth` 中的
       :class:`~django.contrib.auth.models.Permisson` 模型依赖于
       :mod:`django.contrib.contenttypes` 。）
    2. 运行命令 ``manage.py syncdb`` 。

注意：为了方便起见， :djadmin:`django-admin.py startproject` 创建的缺省
:file:`settings.py` 文件的 :setting:`INSTALLED_APPS` 中已包含
``'django.contrib.auth'`` 和 ``'django.contrib.contenttypes'`` 。
如果你的 :setting:`INSTALLED_APPS` 早已包含这些应用，你可以放心地再次运行
:djadmin:`manage.py syncdb` 。这个命令可以多次执行，因为每次它只会安装需要安装
的东西。

:djadmin:`syncdb` 命令创建必须的数据库表和所有已安装应用需要的权限对象。第一次
运行这个命令会提示你创建一个超级用户。

通过以上步骤，认证系统就安装完成了。

用户
=====

.. class:: models.User

API 手册
-------------

字段
~~~~~~

.. class:: models.User

    :class:`~django.contrib.auth.models.User` 对象有以下字段：

    .. attribute:: models.User.username

        必选项。 小于等于 30 个字符。 只能是字母数字（字母、数字和下划线）。

    .. attribute:: models.User.first_name

        可选项。 小于等于 30 个字符。

    .. attribute:: models.User.last_name

        可选项。 小于等于 30 个字符。

    .. attribute:: models.User.email

        可选项。电子邮件地址。

    .. attribute:: models.User.password

        必选项。密码（哈希值，元数据）。 Django 不储存原始密码。原始密码可以是
        任意长度的，包含任何字符。参见下面“密码”一节。

    .. attribute:: models.User.is_staff

        布尔值。指明这个用户是否可以进入管理站点。

    .. attribute:: models.User.is_active

        布尔值。指明这个用户帐户是否是活动的。一般我们不删除帐户而是把这个标记
        设置为 ``False`` 。

        这个属性不控制用户是否可以登录。登录验证时不会核查 ``is_active`` 标志。
        因此，如果在登录时需要检查 ``is_active`` 标志，需要你在自己的登录视图中
        实现。但是当使用象 :meth:`~models.User.has_perm` 的方法检查权限时会检查
        这个标志，如果不是活动用户就会返回 ``False`` 。

    .. attribute:: models.User.is_superuser

        布尔值。指明用户拥有所有权限（包括显式赋予和非显式赋予的）。

    .. attribute:: models.User.last_login

        缺省情况下设置为用户最后一次登录的日期时间。

    .. attribute:: models.User.date_joined

        缺省情况下设置为用户帐户创建的日期时间。

方法
~~~~~~~

.. class:: models.User

    :class:`~django.contrib.auth.models.User` 对象有两个多对多字段
    fields: models.User. ``组（ groups  ）`` 和
    ``用户权限（ user_permissions ）`` 。3
    :class:`~django.contrib.auth.models.User` 对象可以象其它
    :ref:`Django 模型 <topics-db-models>` 一样操作关联对象：

    .. code-block:: python

        myuser.groups = [group_list]
        myuser.groups.add(group, group, ...)
        myuser.groups.remove(group, group, ...)
        myuser.groups.clear()
        myuser.user_permissions = [permission_list]
        myuser.user_permissions.add(permission, permission, ...)
        myuser.user_permissions.remove(permission, permission, ...)
        myuser.user_permissions.clear()

    除了那些自动 API 方法之外， :class:`~django.contrib.auth.models.User` 对象
    还有以下自己的方法：

    .. method:: models.User.is_anonymous()

        总是返回 ``False`` 。这是一个区别
        :class:`~django.contrib.auth.models.User` 和 
        :class:`~django.contrib.auth.models.AnonymousUser` 对象的方法。
        通常，你会更喜欢用
        :meth:`~django.contrib.auth.models.User.is_authenticated()` 来代替这个
        方法。

    .. method:: models.User.is_authenticated()

        总是返回 ``True`` 。这是一个测试用户是否经过验证的方法。这并不表示任何
        权限，也不测试用户是否是活动的。这只是验证用户是否合法，密码是否正确。

    .. method:: models.User.get_full_name()

        返回 :attr:`~django.contrib.auth.models.User.first_name` 加上
        :attr:`~django.contrib.auth.models.User.last_name` ，中间加上一个空格。

    .. method:: models.User.set_password(raw_password)

        根据原始字符串设置用户密码，要注意密码的哈希算法。不保存
        :class:`~django.contrib.auth.models.User` 对象。

    .. method:: models.User.check_password(raw_password)

        如果密码正确则返回 ``True`` 。（在比较密码时要注意哈希算法。）

    .. method:: models.User.set_unusable_password()

        .. versionadded:: 1.0

        使用用户可以不设置密码。这与用户使用空字符串作为密码是不同的。
        对这种用户， :meth:`~django.contrib.auth.models.User.check_password()`
        肯定不会返回 ``True`` 。不保存
        :class:`~django.contrib.auth.models.User` 对象。

        如果你的应用存在于如 LDAP 目录之类的外部来源时，那么可能需要这个方法。

    .. method:: models.User.has_usable_password()

        .. versionadded:: 1.0

        如果对于这个用户调用
        :meth:`~django.contrib.auth.models.User.set_unusable_password()` 则返回
        ``False`` 。

    .. method:: models.User.get_group_permissions()

        通过用户的组返回一个其权限列表。

    .. method:: models.User.get_all_permissions()

        通过用户的组和用户权限返回一个用户权限列表。

    .. method:: models.User.has_perm(perm)

        如果用户有特定的权限则返回 ``True`` ，这里的 perm 的格式为
        ``"<app label>.<permission codename>"`` 。如果用户是不活动的，这个方法
        总是返回 ``False`` 。

    .. method:: models.User.has_perms(perm_list)

        如果用户有列表中每个特定的权限则返回 ``True`` ，这里的 perm 的格式为
        ``"<app label>.<permission codename>"`` 。如果用户是不活动的，这个方法
        总是返回 ``False`` 。

    .. method:: models.User.has_module_perms(package_name)

        如果用户在给定的包（ Django 应用标签）中有任何一个权限则返回
        ``True`` 。如果用户是不活动的，这个方法总是返回 ``False`` 。

    .. method:: models.User.get_and_delete_messages()

        在用户的列表中获得 :class:`~django.contrib.auth.models.Message` 对象
        列表，并从队列中删除。

    .. method:: models.User.email_user(subject, message, from_email=None)

        发送一个电子邮件给用户。如果
        :attr:`~django.contrib.auth.models.User.from_email` 为 ``None`` ，则
        使用 :setting:`DEFAULT_FROM_EMAIL` 。

    .. method:: models.User.get_profile()

        返回用户的特定站点的描述。如果当前站点不提供描述则引发
        :exc:`django.contrib.auth.models.SiteProfileNotAvailable` 。关于定义
        特定站点用户描述，参见下文 `储存用户的额外信息` 一节。

.. _储存用户的额外信息: #storing-additional-information-about-users

管理器函数
~~~~~~~~~~~~~~~~~

.. class:: models.UserManager

    :class:`~django.contrib.auth.models.User` 模型有一个包含以下实用函数的
    自定义管理器：

    .. method:: models.UserManager.create_user(username, email, password=None)

        创建、保存并返回一个 :class:`~django.contrib.auth.models.User` 。
        :attr:`~django.contrib.auth.models.User.username` 属性、
        :attr:`~django.contrib.auth.models.User.email` 属性和
        :attr:`~django.contrib.auth.models.User.password` 属性根据给出的参数
        设置， :class:`~django.contrib.auth.models.User` 设置为
        ``is_active=True`` 。

        如果没有提供密码，就会调用
        :meth:`~django.contrib.auth.models.User.set_unusable_password()` 。

        使用举例参见 `创建用户`_ 。

    .. method:: models.UserManager.make_random_password(length=10, allowed_chars='abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789')

        根据给定的长度和给定的可用字符串返回一个随机密码。注意缺省的可用字符串
        不包括以下容易混淆的字符：

            * ``i`` 、 ``l`` 、 ``I`` 和 ``1`` （小写字母 i 、小写字母 L 、大写
              字母 i 和数字一）
            * ``o`` 、 ``O`` 和 ``0`` （大写字母 o 、小写字母 o 和零）
              and zero)

基本用法
-----------

.. _topics-auth-creating-users:

创建用户
~~~~~~~~~~~~~~

最基本的创建用户的方法是使用 Django 自带的
:meth:`~django.contrib.auth.models.UserManager.create_user` 助理函数::

    >>> from django.contrib.auth.models import User
    >>> user = User.objects.create_user('john', 'lennon@thebeatles.com', 'johnpassword')

    # 到这里， user 是一个已存入数据库的 User 对象。如果要改变其它字段可以继续
    # 改变这个对象的属性。
    >>> user.is_staff = True
    >>> user.save()

你也可以用 Django 的管理站点来创建用户。假设你已经启用了管理站点并把站点挂接到
``/admin/`` ， ``/admin/auth/user/add/`` 页面会有一个“增加用户（ Add user ）”
按钮。在管理站点的主页面中的“认证” 小节中还可以看见一个“用户（ Users ）”
链接。“增加用户”页面与标准的管理站点页面不同之处在于在允许编辑其它用户字段之前
必须确定用户名和密码。

同时要注意：在管理站点中，如果要你的帐户可以创建用户，那么必须有添加 *和* 变更
用户的权限。如果只有添加用户权限而没变更权限，那么是不能创建用户的。因为如果有
添加用户权限，那么就可以添加超级用户，然后就可以变更其他用户。所以 Django 需要
同时具备添加 *和* 变更权限。这是出于安全性考虑。

变更密码
~~~~~~~~~~~~~~~~~~

变更密码使用 :meth:`~django.contrib.auth.models.User.set_password()`:

.. code-block:: python

    >>> from django.contrib.auth.models import User
    >>> u = User.objects.get(username__exact='john')
    >>> u.set_password('new password')
    >>> u.save()

不要直接设置 :attr:`~django.contrib.auth.models.User.password` 属性，除非必须。
下一节会说明原因。

密码
---------

:class:`~django.contrib.auth.models.User` 对象的
:attr:`~django.contrib.auth.models.User.password` 属性是一个如下格式的字符串::

    hashtype$salt$hash

由哈希类型、盐值和哈希值组成，用美元符合分隔。

哈希类型可以是 ``sha1`` （缺省值）、 ``md5`` 或 ``crypt`` ，表明使用哪种单向
哈希算法来处理密码。盐值是一个随机字符串，用于在哈希过程中加盐。注意 ``crypt``
方法只适用于装有标准 Python ``crypt`` 模块的平台下。

.. versionadded:: 1.0
    Django 1.0 开始支持 ``crypt`` 方法。

密码例子::

    sha1$a1976$a36cc8cbf81742a8fb52e221aaeab48ed7f58ab4

:meth:`~django.contrib.auth.models.User.set_password` 方法和
:meth:`~django.contrib.auth.models.User.check_password` 函数用于设置和检查
密码。

以前版本的 Django ，如 0.90 版，只是简单使用 MD5 哈希，并且不使用盐值。为了向后
兼容，这些密码还是被支持的，指定用户的密码在第一次正常使用
:meth:`~django.contrib.auth.models.User.check_password()` 后，会自动转换为新的
形式。

匿名用户
---------------

.. class:: models.AnonymousUser

    :class:`django.contrib.auth.models.AnonymousUser` 是一个
    :class:`django.contrib.auth.models.User` 接口实现的类，区别如下：

    * :attr:`~django.contrib.auth.models.User.id` 总是 ``None`` 。
    * :attr:`~django.contrib.auth.models.User.is_staff` 和
      :attr:`~django.contrib.auth.models.User.is_superuser` 都总是
      ``False`` 。
    * :attr:`~django.contrib.auth.models.User.is_active` 总是 ``False`` 。
    * :attr:`~django.contrib.auth.models.User.groups` 和
      :attr:`~django.contrib.auth.models.User.user_permissions` 都总是空的。
    * :meth:`~django.contrib.auth.models.User.is_anonymous()` 返回 ``True`` ，
      而不是 ``False`` 。
    * :meth:`~django.contrib.auth.models.User.is_authenticated()` 返回
      ``False`` ，而不是 ``True`` 。
    * :meth:`~django.contrib.auth.models.User.has_perm()` 总是返回 ``False`` 。
    * :meth:`~django.contrib.auth.models.User.set_password()` 、
      :meth:`~django.contrib.auth.models.User.check_password()` 、
      :meth:`~django.contrib.auth.models.User.save()` 、
      :meth:`~django.contrib.auth.models.User.delete()` 、
      :meth:`~django.contrib.auth.models.User.set_groups()` 和
      :meth:`~django.contrib.auth.models.User.set_permissions()` 引发
      :exc:`NotImplementedError` 。

在实践中，你一般不会自己使用
:class:`~django.contrib.auth.models.AnonymousUser` 对象，但是 Web 请求会使用，
在下节会详述。

.. _topics-auth-creating-superusers:

创建超级用户
-------------------

.. versionadded:: 1.0
   ``manage.py createsuperuser`` 命令是新增的。

在 :setting:`INSTALLED_APPS` 中添加 ``'django.contrib.auth'`` 后第一次运行
:djadmin:`manage.py syncdb <syncdb>` 会提示你创建一个超级用户。如何在以后单独
创建可以使用以下命令行工具::

    manage.py createsuperuser --username=joe --email=joe@example.com

运行后会提供输入密码。输入密码后，用户会被立即创建。如果没有写明
:djadminopt:`--username` 或 :djadminopt:`--email` ，会提示你输入这两个值。

如果你使用的是老版本的 Django ，则可以使用如下命令::

    python /path/to/django/contrib/auth/create_superuser.py

...这里的 :file:`/path/to` 是你系统中 Django 代码所在路径。推荐使用
``manage.py`` 命令，因为它为你提供了恰当的路径和环境。

.. _auth-profiles:

为用户储存额外的信息
------------------------------------------

如果要储存用户相关的额外信息， Django 提供了一个方法来定义一个站点相关模型，称
之为“用户概况（ user profile ）”。

具体实现的方式是定义一个用于储存额外信息或附加方法的模型，同时在模型中添加一个
:class:`~django.db.models.Field.ForeignKey` 关联到
:class:`~django.contrib.auth.models.User` 模型，还在模型中定义
``unique=True`` ，以保证每个 :class:`~django.contrib.auth.models.User` 只能创建
唯一的你的模型的实例。

为了使定义的模型成为站点的用户概况模型，必须有 :setting:`AUTH_PROFILE_MODULE` 
设置中定义一个包含以下条目的字符串，条目间以点号分隔：

1. 使用用户概况模型的应用名称（大小写敏感）。亦即用来创建应用而传递给
   :djadmin:`manage.py startapp <startapp>` 的名称。

2. 模型的名称（大小写不敏感）。

例如，如果用户概况模型名称为 ``UserProfile`` 且定义在一个名称为 ``accounts`` 的
应用中，那么正确的设置是::

    AUTH_PROFILE_MODULE = 'accounts.UserProfile'

当一个用户概况模型定义好并按上述方法指定之后，每个
:class:`~django.contrib.auth.models.User` 对象就会有一个
:class:`~django.contrib.auth.models.User.get_profile()` 方法，这个方法可以返回
与 :class:`~django.contrib.auth.models.User` 相关联的用户概况模型。

如果用户概况不存在，则 :class:`~django.contrib.auth.models.User.get_profile()`
方法不会创建用户概况。你必需在用户模型中为
:attr:`django.db.models.signals.post_save` 信号注册一个句柄，并且在句柄中，如果
created=True ，则创建相关的用户概况。

更多信息，参见 `Django 之书第十二章`_.

.. _Django 之书第十二章: http://www.djangobook.com/en/1.0/chapter12/#cn222

Web 请求中的认证
================

到这里本文谈得是手动处理认证相关对象的低级 API ，在更高的级别 Django 可以把这个
认证框架挂接到 :class:`request objects <django.http.HttpRequest>` 系统中。

首先，通过 :setting:`MIDDLEWARE_CLASSES` 设置安装
:class:`~django.contrib.sessions.middleware.SessionMiddleware` 和
:class:`~django.contrib.auth.middleware.AuthenticationMiddleware` 中间件。详见
:ref:`session documentation <topics-http-sessions>` 。

安装完中间件后就可以在视图中操作
:attr:`request.user <django.http.HttpRequest.user>` 了。
:attr:`request.user <django.http.HttpRequest.user>` 会给你一个
:class:`~django.contrib.auth.models.User` 对象来表现当前已登录的用户。如果用户
还没有登录，那么 :attr:`request.user <django.http.HttpRequest.user>` 会被设置为
一个 :class:`~django.contrib.auth.models.AnonymousUser` 的实例（参见前一节）。
你可以用于 :meth:`~django.contrib.auth.models.User.is_authenticated()` 来区别
对待，如下例::

    if request.user.is_authenticated():
        # 做一些已登录用户的事。
    else:
        # 做一些匿名用户的事。

.. _howtologauserin:

如何登录一个用户
--------------------

Django 在 :mod:`django.contrib.auth` 模型中提供两个函数:
:func:`~django.contrib.auth.authenticate()` 和
:func:`~django.contrib.auth.login()` .

.. function:: authenticate()

    :func:`~django.contrib.auth.authenticate()` 用于验证指定用户的用户名和
    密码。这个函数有两个关键字参数， ``username`` 和 ``password`` ，如果密码与
    用户匹配则返回一个 :class:`~django.contrib.auth.models.User` 对象。否则返回
    ``None`` 。例如::

        from django.contrib.auth import authenticate
        user = authenticate(username='john', password='secret')
        if user is not None:
            if user.is_active:
                print "你提供了一个正确的用户名和密码！"
            else:
                print "帐户已禁用！"
        else:
            print "用户名或密码不正确。"

.. function:: login()

    :func:`~django.contrib.auth.login()` 用于在视图中登录用户。它带有一个
    :class:`~django.http.HttpRequest` 对象和一个
    :class:`~django.contrib.auth.models.User` 对象。
    :func:`~django.contrib.auth.login()` 使用 Django 的会话框架在会话中保存用户
    的 ID 。因此如前文所述，会话中间件必须已经安装。

    本例展示如何同时使用 :func:`~django.contrib.auth.authenticate()` 和
    :func:`~django.contrib.auth.login()`::

        from django.contrib.auth import authenticate, login

        def my_view(request):
            username = request.POST['username']
            password = request.POST['password']
            user = authenticate(username=username, password=password)
            if user is not None:
                if user.is_active:
                    login(request, user)
                    # 重定向到一个登录成功页面。
                else:
                    # 返回一个“帐户已禁用”错误信息。
            else:
                # 返回一个“非法用户名或密码”错误信息。

.. admonition:: 首先调用 ``authenticate()``

    当你手动登录一个用户时， *必须* 在调用
    :func:`~django.contrib.auth.login()` 之前调用
    :func:`~django.contrib.auth.authenticate()` 。在成功验证用户后，
    :func:`~django.contrib.auth.authenticate()` 会在
    :class:`~django.contrib.auth.models.User` 上设置一个空属性（详见
    `后台处理文档`_ ），这个信息在以后登录过程中要用到。

.. _后台处理文档: #other-authentication-sources

手动检查一个用户的密码
----------------------

.. function:: check_password()

    如果要通过比较明文密码和数据库中的哈希密码来手动认证用户，可以使用便捷的
    :func:`django.contrib.auth.models.check_password` 函数。它带有两个参数：要
    比较的明文密码和被比较的数据库中用户 ``密码`` 字段的完整值。如果匹配则返回
    ``True`` ，否则返回 ``False`` 。

如何登出一个用户
----------------

.. function:: logout()

    在视图中可以使用 :func:`django.contrib.auth.logout()` 来登出通过
    :func:`django.contrib.auth.login()` 登录的用户。它带有一个
    :class:`~django.http.HttpRequest` 对象，没有返回值。
    例如::

        from django.contrib.auth import logout

        def logout_view(request):
            logout(request)
            # 重定向到一个登出成功页面。

    注意当用户没有登录时，调用 :func:`~django.contrib.auth.logout()` 函数不会
    引发任何错误。

    .. versionchanged:: 1.0
       调用 ``logout()`` ，现在会清除会话数据。

    当调用 :func:`~django.contrib.auth.logout()` 时，当前请求的会话数据会清空。
    这是为了防止另一个用户使用同一个浏览器登录时会使用到前一个用户的会话数据。
    如果要在用户登出后有会话中储存一些数据，那么得在
    :func:`django.contrib.auth.logout()` *之后* 储存。

控制非登录用户的页面权限
----------------------------------

原始方式
~~~~~~~~~~~

页面限制的简单原始方式是检查 :meth:`request.user.is_authenticated()
<django.contrib.auth.models.User.is_authenticated()>` 并且重定向到一个登录
页面::

    from django.http import HttpResponseRedirect

    def my_view(request):
        if not request.user.is_authenticated():
            return HttpResponseRedirect('/login/?next=%s' % request.path)
        # ...

...或显示一个出错页面::

    def my_view(request):
        if not request.user.is_authenticated():
            return render_to_response('myapp/login_error.html')
        # ...

登录要求饰件
~~~~~~~~~~~~

.. function:: decorators.login_required()

    做为一个捷径，可以使用方便的
    :func:`~django.contrib.auth.decorators.login_required` 饰件::

        from django.contrib.auth.decorators import login_required

        def my_view(request):
            # ...
        my_view = login_required(my_view)

    换一种方式，使用 Python 2.4 中引入的紧凑的装饰语法::

        from django.contrib.auth.decorators import login_required

        @login_required
        def my_view(request):
            # ...

    :func:`~django.contrib.auth.decorators.login_required` 也可以接受一个可选的
    ``redirect_field_name`` 参数。例如::

        from django.contrib.auth.decorators import login_required

        def my_view(request):
            # ...
        my_view = login_required(redirect_field_name='redirect_to')(my_view)

    同上，紧凑型的::

        from django.contrib.auth.decorators import login_required

        @login_required(redirect_field_name='redirect_to')
        def my_view(request):
            # ...

    :func:`~django.contrib.auth.decorators.login_required` 做以下式作：

        * 如果用户没有登录，则重定向到
          :setting:`settings.LOGIN_URL <LOGIN_URL>` （缺少情况下为
          ``/accounts/login/`` ），并在查询字符串中传递当前绝对路径。 GET 参数
          的名称由饰件的 ``redirect_field_name`` 参数决定。缺省的参数是
          ``next`` 。例如：
          ``/accounts/login/?next=/polls/3/``.

        * 如果用户已登录，则正常的执行视图。

注意：你需要为 :setting:`settings.LOGIN_URL <LOGIN_URL>` 映射适当的视图。例如，
在缺省情况下，在你的 URLconf 中加入以下一行::

    (r'^accounts/login/$', 'django.contrib.auth.views.login'),

.. function:: views.login(request, [template_name, redirect_field_name])

    以下是 ``django.contrib.auth.views.login`` 做了什么：

        * 如果是通过 ``GET`` 调用的，则显示一个 POST 到相同 URL 的登录表单。
          稍后会以更多的说明。

        * 如果是通过 ``POST`` 调用的，则会尝试登录用户。如果登录成功，则会重
          定向到 ``next`` 指定的 URL 。如果 ``next`` 没有提供，则重定向到
          :setting:`settings.LOGIN_REDIRECT_URL <LOGIN_REDIRECT_URL>` （缺省
          的是 ``/accounts/profile/`` ）。如果登录不成功，则重新显示登录表单。

    缺省情况下，在名为 ``registration/login.html`` 的模板中提供一个登录表单是
    你的责任。这个模板要传递四个环境变量：

        * ``form``: 一个表现登录表单的 :class:`~django.forms.Form` 对象。关于
          ``Form`` 对象的更多内容
          :ref:`表单文档 <topics-forms-index>` 。

        * ``next``: 登录成功后要重定向的 URL 。也可以包含一个查询字符串。

        * ``site``: 当前的 :class:`~django.contrib.sites.models.Site` ，依赖于
          :setting:`SITE_ID` 设置。如果没有安装站点框架，则会被设置为一个
          :class:`~django.contrib.sites.models.RequestSite` 实例, which derives the
          site name and domain from the current
          :class:`~django.http.HttpRequest`.

        * ``site_name``: An alias for ``site.name``. If you don't have the site
          framework installed, this will be set to the value of
          :attr:`request.META['SERVER_NAME'] <django.http.HttpRequest.META>`.
          For more on sites, see :ref:`ref-contrib-sites`.

    If you'd prefer not to call the template :file:`registration/login.html`,
    you can pass the ``template_name`` parameter via the extra arguments to
    the view in your URLconf. For example, this URLconf line would use
    :file:`myapp/login.html` instead::

        (r'^accounts/login/$', 'django.contrib.auth.views.login', {'template_name': 'myapp/login.html'}),

    You can also specify the name of the ``GET`` field which contains the URL
    to redirect to after login by passing ``redirect_field_name`` to the view.
    By default, the field is called ``next``.

    Here's a sample :file:`registration/login.html` template you can use as a
    starting point. It assumes you have a :file:`base.html` template that
    defines a ``content`` block:

    .. code-block:: html

        {% extends "base.html" %}

        {% block content %}

        {% if form.errors %}
        <p>Your username and password didn't match. Please try again.</p>
        {% endif %}

        <form method="post" action="{% url django.contrib.auth.views.login %}">
        <table>
        <tr>
            <td>{{ form.username.label_tag }}</td>
            <td>{{ form.username }}</td>
        </tr>
        <tr>
            <td>{{ form.password.label_tag }}</td>
            <td>{{ form.password }}</td>
        </tr>
        </table>

        <input type="submit" value="login" />
        <input type="hidden" name="next" value="{{ next }}" />
        </form>

        {% endblock %}

    .. _forms documentation: ../forms/
    .. _site framework docs: ../sites/

Other built-in views
--------------------

In addition to the :func:`~views.login` view, the authentication system
includes a few other useful built-in views located in
:mod:`django.contrib.auth.views`:

.. function:: views.logout(request, [next_page, template_name, redirect_field_name])

    Logs a user out.

    **Optional arguments:**

        * ``next_page``: The URL to redirect to after logout.

        * ``template_name``: The full name of a template to display after
          logging the user out. This will default to
          :file:`registration/logged_out.html` if no argument is supplied.

        * ``redirect_field_name``: The name of a ``GET`` field containing the
          URL to redirect to after log out. Overrides ``next_page`` if the given
          ``GET`` parameter is passed.

    **Template context:**

        * ``title``: The string "Logged out", localized.

.. function:: views.logout_then_login(request[, login_url])

    Logs a user out, then redirects to the login page.

    **Optional arguments:**

        * ``login_url``: The URL of the login page to redirect to. This will
          default to :setting:`settings.LOGIN_URL <LOGIN_URL>` if not supplied.

.. function:: views.password_change(request[, template_name, post_change_redirect])

    Allows a user to change their password.

    **Optional arguments:**

        * ``template_name``: The full name of a template to use for
          displaying the password change form. This will default to
          :file:`registration/password_change_form.html` if not supplied.

        * ``post_change_redirect``: The URL to redirect to after a successful
          password change.

    **Template context:**

        * ``form``: The password change form.

.. function:: views.password_change_done(request[, template_name])

    The page shown after a user has changed their password.

    **Optional arguments:**

        * ``template_name``: The full name of a template to use. This will
          default to :file:`registration/password_change_done.html` if not
          supplied.

.. function:: views.password_reset(request[, is_admin_site, template_name, email_template_name, password_reset_form, token_generator, post_reset_redirect])

    Allows a user to reset their password, and sends them the new password
    in an e-mail.

    **Optional arguments:**

        * ``template_name``: The full name of a template to use for
          displaying the password reset form. This will default to
          :file:`registration/password_reset_form.html` if not supplied.

        * ``email_template_name``: The full name of a template to use for
          generating the e-mail with the new password. This will default to
          :file:`registration/password_reset_email.html` if not supplied.

        * ``password_reset_form``: Form that will be used to set the password.
          Defaults to ``SetPasswordForm``.

        * ``token_generator``: Instance of the class to check the password. This
          will default to ``default_token_generator``, it's an instance of
          ``django.contrib.auth.tokens.PasswordResetTokenGenerator``.

        * ``post_reset_redirect``: The URL to redirect to after a successful
          password change.

    **Template context:**

        * ``form``: The form for resetting the user's password.

.. function:: views.password_reset_done(request[, template_name])

    The page shown after a user has reset their password.

    **Optional arguments:**

        * ``template_name``: The full name of a template to use. This will
          default to :file:`registration/password_reset_done.html` if not
          supplied.

.. function:: views.redirect_to_login(next[, login_url, redirect_field_name])

    Redirects to the login page, and then back to another URL after a
    successful login.

    **Required arguments:**

        * ``next``: The URL to redirect to after a successful login.

    **Optional arguments:**

        * ``login_url``: The URL of the login page to redirect to. This will
          default to :setting:`settings.LOGIN_URL <LOGIN_URL>` if not supplied.

        * ``redirect_field_name``: The name of a ``GET`` field containing the
          URL to redirect to after log out. Overrides ``next`` if the given
          ``GET`` parameter is passed.

.. function:: password_reset_confirm(request[, uidb36, token, template_name, token_generator, set_password_form, post_reset_redirect])

    Presents a form for entering a new password.

    **Optional arguments:**

        * ``uidb36``: The user's id encoded in base 36. This will default to
          ``None``.
        * ``token``: Token to check that the password is valid. This will default to ``None``.
        * ``template_name``: The full name of a template to display the confirm
          password view. Default value is :file:`registration/password_reset_confirm.html`.
        * ``token_generator``: Instance of the class to check the password. This
          will default to ``default_token_generator``, it's an instance of
          ``django.contrib.auth.tokens.PasswordResetTokenGenerator``.
        * ``set_password_form``: Form that will be used to set the password.
          This will default to ``SetPasswordForm``.
        * ``post_reset_redirect``: URL to redirect after the password reset
          done. This will default to ``None``.

.. function:: password_reset_complete(request[,template_name])

   Presents a view which informs the user that the password has been
   successfully changed.

   **Optional arguments:**

       * ``template_name``: The full name of a template to display the view.
         This will default to :file:`registration/password_reset_complete.html`.

Built-in forms
--------------

.. module:: django.contrib.auth.forms

If you don't want to use the built-in views, but want the convenience of not
having to write forms for this functionality, the authentication system
provides several built-in forms located in :mod:`django.contrib.auth.forms`:

.. class:: AdminPasswordChangeForm

    A form used in the admin interface to change a user's password.

.. class:: AuthenticationForm

    A form for logging a user in.

.. class:: PasswordChangeForm

    A form for allowing a user to change their password.

.. class:: PasswordResetForm

    A form for resetting a user's password and e-mailing the new password to
    them.

.. class:: SetPasswordForm

    A form that lets a user change his/her password without entering the old
    password.

.. class:: UserChangeForm

    A form used in the admin interface to change a user's information and
    permissions.

.. class:: UserCreationForm

    A form for creating a new user.

Limiting access to logged-in users that pass a test
---------------------------------------------------

.. currentmodule:: django.contrib.auth

To limit access based on certain permissions or some other test, you'd do
essentially the same thing as described in the previous section.

The simple way is to run your test on :attr:`request.user
<django.http.HttpRequest.user>` in the view directly. For example, this view
checks to make sure the user is logged in and has the permission
``polls.can_vote``::

    def my_view(request):
        if not (request.user.is_authenticated() and request.user.has_perm('polls.can_vote')):
            return HttpResponse("You can't vote in this poll.")
        # ...

.. function:: decorators.user_passes_test()

    As a shortcut, you can use the convenient ``user_passes_test`` decorator::

        from django.contrib.auth.decorators import user_passes_test

        def my_view(request):
            # ...
        my_view = user_passes_test(lambda u: u.has_perm('polls.can_vote'))(my_view)

    We're using this particular test as a relatively simple example. However,
    if you just want to test whether a permission is available to a user, you
    can use the :func:`~django.contrib.auth.decorators.permission_required()`
    decorator, described later in this document.

    Here's the same thing, using Python 2.4's decorator syntax::

        from django.contrib.auth.decorators import user_passes_test

        @user_passes_test(lambda u: u.has_perm('polls.can_vote'))
        def my_view(request):
            # ...

    :func:`~django.contrib.auth.decorators.user_passes_test` takes a required
    argument: a callable that takes a
    :class:`~django.contrib.auth.models.User` object and returns ``True`` if
    the user is allowed to view the page. Note that
    :func:`~django.contrib.auth.decorators.user_passes_test` does not
    automatically check that the :class:`~django.contrib.auth.models.User` is
    not anonymous.

    :func:`~django.contrib.auth.decorators.user_passes_test()` takes an
    optional ``login_url`` argument, which lets you specify the URL for your
    login page (:setting:`settings.LOGIN_URL <LOGIN_URL>` by default).

    Example in Python 2.3 syntax::

        from django.contrib.auth.decorators import user_passes_test

        def my_view(request):
            # ...
        my_view = user_passes_test(lambda u: u.has_perm('polls.can_vote'), login_url='/login/')(my_view)

    Example in Python 2.4 syntax::

        from django.contrib.auth.decorators import user_passes_test

        @user_passes_test(lambda u: u.has_perm('polls.can_vote'), login_url='/login/')
        def my_view(request):
            # ...

The permission_required decorator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. function:: decorators.permission_required()

    It's a relatively common task to check whether a user has a particular
    permission. For that reason, Django provides a shortcut for that case: the
    :func:`~django.contrib.auth.decorators.permission_required()` decorator.
    Using this decorator, the earlier example can be written as::

        from django.contrib.auth.decorators import permission_required

        def my_view(request):
            # ...
        my_view = permission_required('polls.can_vote')(my_view)

    As for the :meth:`User.has_perm` method, permission names take the form
    ``"<app label>.<permission codename>"`` (i.e. ``polls.can_vote`` for a
    permission on a model in the ``polls`` application).

    Note that :func:`~django.contrib.auth.decorators.permission_required()`
    also takes an optional ``login_url`` parameter. Example::

        from django.contrib.auth.decorators import permission_required

        def my_view(request):
            # ...
        my_view = permission_required('polls.can_vote', login_url='/loginpage/')(my_view)

    As in the :func:`~decorators.login_required` decorator, ``login_url``
    defaults to :setting:`settings.LOGIN_URL <LOGIN_URL>`.

Limiting access to generic views
--------------------------------

To limit access to a :ref:`generic view <ref-generic-views>`, write a thin
wrapper around the view, and point your URLconf to your wrapper instead of the
generic view itself. For example::

    from django.views.generic.date_based import object_detail

    @login_required
    def limited_object_detail(*args, **kwargs):
        return object_detail(*args, **kwargs)

Permissions
===========

Django comes with a simple permissions system. It provides a way to assign
permissions to specific users and groups of users.

It's used by the Django admin site, but you're welcome to use it in your own
code.

The Django admin site uses permissions as follows:

    * Access to view the "add" form and add an object is limited to users with
      the "add" permission for that type of object.
    * Access to view the change list, view the "change" form and change an
      object is limited to users with the "change" permission for that type of
      object.
    * Access to delete an object is limited to users with the "delete"
      permission for that type of object.

Permissions are set globally per type of object, not per specific object
instance. For example, it's possible to say "Mary may change news stories," but
it's not currently possible to say "Mary may change news stories, but only the
ones she created herself" or "Mary may only change news stories that have a
certain status, publication date or ID." The latter functionality is something
Django developers are currently discussing.

Default permissions
-------------------

When ``django.contrib.auth`` is listed in your :setting:`INSTALLED_APPS`
setting, it will ensure that three default permissions -- add, change and
delete -- are created for each Django model defined in one of your installed
applications.

These permissions will be created when you run :djadmin:`manage.py syncdb
<syncdb>`; the first time you run ``syncdb`` after adding
``django.contrib.auth`` to :setting:`INSTALLED_APPS`, the default permissions
will be created for all previously-installed models, as well as for any new
models being installed at that time. Afterward, it will create default
permissions for new models each time you run :djadmin:`manage.py syncdb
<syncdb>`.

.. _custom-permissions:

Custom permissions
------------------

To create custom permissions for a given model object, use the ``permissions``
:ref:`model Meta attribute <meta-options>`.

This example model creates three custom permissions::

    class USCitizen(models.Model):
        # ...
        class Meta:
            permissions = (
                ("can_drive", "Can drive"),
                ("can_vote", "Can vote in elections"),
                ("can_drink", "Can drink alcohol"),
            )

The only thing this does is create those extra permissions when you run
:djadmin:`manage.py syncdb <syncdb>`.

API reference
-------------

.. class:: models.Permission

    Just like users, permissions are implemented in a Django model that lives
    in `django/contrib/auth/models.py`_.

.. _django/contrib/auth/models.py: http://code.djangoproject.com/browser/django/trunk/django/contrib/auth/models.py

Fields
~~~~~~

:class:`~django.contrib.auth.models.Permission` objects have the following
fields:

.. attribute:: models.Permission.name

    Required. 50 characters or fewer. Example: ``'Can vote'``.

.. attribute:: models.Permission.content_type

    Required. A reference to the ``django_content_type`` database table, which
    contains a record for each installed Django model.

.. attribute:: models.Permission.codename

    Required. 100 characters or fewer. Example: ``'can_vote'``.

Methods
~~~~~~~

:class:`~django.contrib.auth.models.Permission` objects have the standard
data-access methods like any other :ref:`Django model <ref-models-instances>`.

Authentication data in templates
================================

The currently logged-in user and his/her permissions are made available in the
:ref:`template context <ref-templates-api>` when you use
:class:`~django.template.context.RequestContext`.

.. admonition:: Technicality

   Technically, these variables are only made available in the template context
   if you use :class:`~django.template.context.RequestContext` *and* your
   :setting:`TEMPLATE_CONTEXT_PROCESSORS` setting contains
   ``"django.core.context_processors.auth"``, which is default. For more, see
   the :ref:`RequestContext docs <subclassing-context-requestcontext>`.

Users
-----

When rendering a template :class:`~django.template.context.RequestContext`, the
currently logged-in user, either a  :class:`~django.contrib.auth.models.User`
instance or an :class:`~django.contrib.auth.models.AnonymousUser` instance, is
stored in the template variable ``{{ user }}``:

.. code-block:: html

    {% if user.is_authenticated %}
        <p>Welcome, {{ user.username }}. Thanks for logging in.</p>
    {% else %}
        <p>Welcome, new user. Please log in.</p>
    {% endif %}

This template context variable is not available if a ``RequestContext`` is not
being used.

Permissions
-----------

The currently logged-in user's permissions are stored in the template variable
``{{ perms }}``. This is an instance of
:class:`django.core.context_processors.PermWrapper`, which is a
template-friendly proxy of permissions.

In the ``{{ perms }}`` object, single-attribute lookup is a proxy to
:meth:`User.has_module_perms <django.contrib.auth.models.User.has_module_perms>`.
This example would display ``True`` if the logged-in user had any permissions
in the ``foo`` app::

    {{ perms.foo }}

Two-level-attribute lookup is a proxy to
:meth:`User.has_perm <django.contrib.auth.models.User.has_perm>`. This example
would display ``True`` if the logged-in user had the permission
``foo.can_vote``::

    {{ perms.foo.can_vote }}

Thus, you can check permissions in template ``{% if %}`` statements:

.. code-block:: html

    {% if perms.foo %}
        <p>You have permission to do something in the foo app.</p>
        {% if perms.foo.can_vote %}
            <p>You can vote!</p>
        {% endif %}
        {% if perms.foo.can_drive %}
            <p>You can drive!</p>
        {% endif %}
    {% else %}
        <p>You don't have permission to do anything in the foo app.</p>
    {% endif %}

Groups
======

Groups are a generic way of categorizing users so you can apply permissions, or
some other label, to those users. A user can belong to any number of groups.

A user in a group automatically has the permissions granted to that group. For
example, if the group ``Site editors`` has the permission
``can_edit_home_page``, any user in that group will have that permission.

Beyond permissions, groups are a convenient way to categorize users to give
them some label, or extended functionality. For example, you could create a
group ``'Special users'``, and you could write code that could, say, give them
access to a members-only portion of your site, or send them members-only e-mail
messages.

Messages
========

The message system is a lightweight way to queue messages for given users.

A message is associated with a :class:`~django.contrib.auth.models.User`.
There's no concept of expiration or timestamps.

Messages are used by the Django admin after successful actions. For example,
``"The poll Foo was created successfully."`` is a message.

The API is simple:

.. method:: models.User.message_set.create(message)

    To create a new message, use
    ``user_obj.message_set.create(message='message_text')``.

    To retrieve/delete messages, use
    :meth:`user_obj.get_and_delete_messages() <django.contrib.auth.models.User.get_and_delete_messages>`,
    which returns a list of ``Message`` objects in the user's queue (if any)
    and deletes the messages from the queue.

In this example view, the system saves a message for the user after creating
a playlist::

    def create_playlist(request, songs):
        # Create the playlist with the given songs.
        # ...
        request.user.message_set.create(message="Your playlist was added successfully.")
        return render_to_response("playlists/create.html",
            context_instance=RequestContext(request))

When you use :class:`~django.template.context.RequestContext`, the currently
logged-in user and his/her messages are made available in the
:ref:`template context <ref-templates-api>` as the template variable
``{{ messages }}``. Here's an example of template code that displays messages:

.. code-block:: html

    {% if messages %}
    <ul>
        {% for message in messages %}
        <li>{{ message }}</li>
        {% endfor %}
    </ul>
    {% endif %}

Note that :class:`~django.template.context.RequestContext` calls
:meth:`~django.contrib.auth.models.User.get_and_delete_messages` behind the
scenes, so any messages will be deleted even if you don't display them.

Finally, note that this messages framework only works with users in the user
database. To send messages to anonymous users, use the
:ref:`session framework <topics-http-sessions>`.

.. _authentication-backends:

Other authentication sources
============================

The authentication that comes with Django is good enough for most common cases,
but you may have the need to hook into another authentication source -- that
is, another source of usernames and passwords or authentication methods.

For example, your company may already have an LDAP setup that stores a username
and password for every employee. It'd be a hassle for both the network
administrator and the users themselves if users had separate accounts in LDAP
and the Django-based applications.

So, to handle situations like this, the Django authentication system lets you
plug in other authentication sources. You can override Django's default
database-based scheme, or you can use the default system in tandem with other
systems.

See the :ref:`authentication backend reference <ref-authentication-backends>`
for information on the authentication backends included with Django.

Specifying authentication backends
----------------------------------

Behind the scenes, Django maintains a list of "authentication backends" that it
checks for authentication. When somebody calls
:func:`django.contrib.auth.authenticate()` -- as described in :ref:`How to log
a user in` above -- Django tries authenticating across all of its
authentication backends. If the first authentication method fails, Django tries
the second one, and so on, until all backends have been attempted.

The list of authentication backends to use is specified in the
:setting:`AUTHENTICATION_BACKENDS` setting. This should be a tuple of Python
path names that point to Python classes that know how to authenticate. These
classes can be anywhere on your Python path.

By default, :setting:`AUTHENTICATION_BACKENDS` is set to::

    ('django.contrib.auth.backends.ModelBackend',)

That's the basic authentication scheme that checks the Django users database.

The order of :setting:`AUTHENTICATION_BACKENDS` matters, so if the same
username and password is valid in multiple backends, Django will stop
processing at the first positive match.

.. note::

    Once a user has authenticated, Django stores which backend was used to
    authenticate the user in the user's session, and re-uses the same backend
    for subsequent authentication attempts for that user. This effectively means
    that authentication sources are cached, so if you change
    :setting:`AUTHENTICATION_BACKENDS`, you'll need to clear out session data if
    you need to force users to re-authenticate using different methods. A simple
    way to do that is simply to execute ``Session.objects.all().delete()``.

Writing an authentication backend
---------------------------------

An authentication backend is a class that implements two methods:
``get_user(user_id)`` and ``authenticate(**credentials)``.

The ``get_user`` method takes a ``user_id`` -- which could be a username,
database ID or whatever -- and returns a ``User`` object.

The ``authenticate`` method takes credentials as keyword arguments. Most of
the time, it'll just look like this::

    class MyBackend:
        def authenticate(self, username=None, password=None):
            # Check the username/password and return a User.

But it could also authenticate a token, like so::

    class MyBackend:
        def authenticate(self, token=None):
            # Check the token and return a User.

Either way, ``authenticate`` should check the credentials it gets, and it
should return a ``User`` object that matches those credentials, if the
credentials are valid. If they're not valid, it should return ``None``.

The Django admin system is tightly coupled to the Django ``User`` object
described at the beginning of this document. For now, the best way to deal with
this is to create a Django ``User`` object for each user that exists for your
backend (e.g., in your LDAP directory, your external SQL database, etc.) You
can either write a script to do this in advance, or your ``authenticate``
method can do it the first time a user logs in.

Here's an example backend that authenticates against a username and password
variable defined in your ``settings.py`` file and creates a Django ``User``
object the first time a user authenticates::

    from django.conf import settings
    from django.contrib.auth.models import User, check_password

    class SettingsBackend:
        """
        Authenticate against the settings ADMIN_LOGIN and ADMIN_PASSWORD.

        Use the login name, and a hash of the password. For example:

        ADMIN_LOGIN = 'admin'
        ADMIN_PASSWORD = 'sha1$4e987$afbcf42e21bd417fb71db8c66b321e9fc33051de'
        """
        def authenticate(self, username=None, password=None):
            login_valid = (settings.ADMIN_LOGIN == username)
            pwd_valid = check_password(password, settings.ADMIN_PASSWORD)
            if login_valid and pwd_valid:
                try:
                    user = User.objects.get(username=username)
                except User.DoesNotExist:
                    # Create a new user. Note that we can set password
                    # to anything, because it won't be checked; the password
                    # from settings.py will.
                    user = User(username=username, password='get from settings.py')
                    user.is_staff = True
                    user.is_superuser = True
                    user.save()
                return user
            return None

        def get_user(self, user_id):
            try:
                return User.objects.get(pk=user_id)
            except User.DoesNotExist:
                return None

Handling authorization in custom backends
-----------------------------------------

Custom auth backends can provide their own permissions.

The user model will delegate permission lookup functions
(:meth:`~django.contrib.auth.models.User.get_group_permissions()`,
:meth:`~django.contrib.auth.models.User.get_all_permissions()`,
:meth:`~django.contrib.auth.models.User.has_perm()`, and
:meth:`~django.contrib.auth.models.User.has_module_perms()`) to any
authentication backend that implements these functions.

The permissions given to the user will be the superset of all permissions
returned by all backends. That is, Django grants a permission to a user that
any one backend grants.

The simple backend above could implement permissions for the magic admin
fairly simply::

    class SettingsBackend:

        # ...

        def has_perm(self, user_obj, perm):
            if user_obj.username == settings.ADMIN_LOGIN:
                return True
            else:
                return False

This gives full permissions to the user granted access in the above example.
Notice that the backend auth functions all take the user object as an argument,
and they also accept the same arguments given to the associated
:class:`django.contrib.auth.models.User` functions.

A full authorization implementation can be found in
`django/contrib/auth/backends.py`_, which is the default backend and queries
the ``auth_permission`` table most of the time.

.. _django/contrib/auth/backends.py: http://code.djangoproject.com/browser/django/trunk/django/contrib/auth/backends.py
