==============================
管理数据库事务
==============================

.. module:: django.db.transaction

如果你的数据库支持事务，那么 Django 提供了控制事务的多种方式。

Django 的缺省事务行为
=====================================

缺省情况下， Django 运行的是开放性的事务，即当调用任何内建的改变数据的模型函数
时事务会自动提交。例如，如果你 ``model.save()`` 或 ``model.delete()`` ，数据
变动会自动立即提交。

这样很象大多数数据库设置的自动提交。一旦你执行了一个需要写数据库的动作，那么
Django 会执行 ``INSERT``/``UPDATE``/``DELETE`` 语句，然后提交，不会有隐式
``回滚`` 。

把事务与到 HTTP 请求绑定
========================

推荐的方式是通过 Django 的 ``TransactionMiddleware`` 来进行绑定。

其工作原理就象这样：当一个请求开始时， Django 就开始一个事务。如果顺利产生一个
响应， Django 就提交这个阶段的事务。如果视图函数产生异常，就回滚。

要使用这个功能，只在把 ``TransactionMiddleware`` 中间件加入到
:setting:`MIDDLEWARE_CLASSES` 设置中::

    MIDDLEWARE_CLASSES = (
        'django.middleware.cache.UpdateCacheMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.transaction.TransactionMiddleware',
        'django.middleware.cache.FetchFromCacheMiddleware',
    )

这些中间件的顺序是非常重要的。事务中间件不仅作用于视图函数，还作用于其后面的
所有中间件模块。所以如果你把会话中间件放在事务中间件之后，那么会话创建也会变成
事务的一部分。

但以一几种中间件例外：
:class:`~django.middleware.cache.CacheMiddleware` 、
:class:`~django.middleware.cache.UpdateCacheMiddleware` 和
:class:`~django.middleware.cache.FetchFromCacheMiddleware` 。
即使使用了数据库缓存， Django 的缓存后端还是使用其自己的数据库指针（指针内部
映射到其自己的数据库连接）。

.. _transaction-management-functions:

在视图中控制事务管理
===========================================

.. versionchanged:: 1.3
   Django 1.3 新增了事务管理环境管理器

对于大多数人来说，隐匿的基于请求的事务相当好用。但是如果要细粒度地控制事务
管理，那么可以使用 ``django.db.transaction`` 中的一套函数来达到函数级别或代码块
级别的事务控制。

这些函数可以以两种方式使用：

    * 放在常用函数上，作为一个 装饰器_ 。例如::

            from django.db import transaction

            @transaction.commit_on_success()
            def viewfunc(request):
                # ...
                # 在事务内执行的代码
                # ...

      这个功能在所支持的 Python 版本（大于等于 2.4 ）中都可以使用。

    * 作为一个环绕代码块的 `环境管理器`_ ::

            from django.db import transaction

            def viewfunc(request):
                # ...
                # 在缺省事务管理下运行的代码
                # ...

                with transaction.commit_on_success():
                    # ...
                    # 在一个事务内运行的代码
                    # ...

      ``with`` 语句是 Python 2.5 新增的，所以这种方式只能用于 Python 2.5 版及
      以上版本。

.. _装饰器: http://docs.python.org/glossary.html#term-decorator
.. _环境管理器: http://docs.python.org/glossary.html#term-context-manager

为保证最大兼容，以下所有的例子均使用装饰器方式，但是所有例子都可以以环境管理器
的方式使用。

.. note::

    虽然以下例子使用视图函数来举例，但是这些装饰器和环境管理器可以需要管理事务
    的任何地方使用。

.. _topics-db-transactions-autocommit:

.. function:: autocommit

    使用 ``autocommit`` 装饰器可以更换 Django 的缺省提交行为，使其不同于全局
    事务设定。

    例如::

        from django.db import transaction

        @transaction.autocommit
        def viewfunc(request):
            ....

        @transaction.autocommit(using="my_other_database")
        def viewfunc2(request):
            ....

    在 ``viewfunc()`` 中当调用 ``model.save()`` 、 ``model.delete()`` 或其他写
    数据库函数时，事务会立即提交。在 ``viewfunc2()`` 中也会立即提交，但是使用的
    是 ``"my_other_database"`` 连接。

.. function:: commit_on_success

    使用 ``commit_on_success`` 装饰器可以让同一个函数内的工作只使用一个事务::

        from django.db import transaction

        @transaction.commit_on_success
        def viewfunc(request):
            ....

        @transaction.commit_on_success(using="my_other_database")
        def viewfunc2(request):
            ....

    如果函数成功返回，那么 Django 会提交该函数内的所有工作。如果函数产生一个
    异常，那么就会回滚这个事务。

.. function:: commit_manually

    如果你想完全控制事务，那么可以使用 ``commit_manually`` 装饰器。这个装饰器
    告诉 Django ：我要自己动手管理事务。

    如果你的视图改变了数据之后没有 ``commit()`` 或 ``rollback()`` ，那么
    Django 抛出一个 ``TransactionManagementError`` 异常。

    手动事务管理举例如下::

        from django.db import transaction

        @transaction.commit_manually
        def viewfunc(request):
            ...
            # 你可以自由控制如何或何时提交或回滚
            transaction.commit()
            ...

            # 但是不要忘记提交或回滚！
            try:
                ...
            except:
                transaction.rollback()
            else:
                transaction.commit()

        @transaction.commit_manually(using="my_other_database")
        def viewfunc2(request):
            ....

.. _topics-db-transactions-requirements:

事务处理需求
=====================================

.. versionadded:: 1.3

Django 规定一个请求完成前每个开放的事务必须关闭。如果你使用:func:`autocommit`
（缺省的提交方式）或 :func:`commit_on_success` ，那么这事是自动进行的，不用你
操心。但是如果你手动管理事务（使用 :func:`commit_manually` 装饰器），那么你必须
确保在请求完成完成前，事务都已提交或回滚。

这个规则适用于所有数据库操作，而不仅仅是写操作。甚至只是从数据库中读数据，事务
也必须在请求完成之前提交或回滚。

如果全局性停用事务管理
=================================================

在 Django 设置文件中设置 ``DISABLE_TRANSACTION_MANAGEMENT`` 为 ``True`` 可以
满足控制狂人停用所有事务管理的需求。

如果停用了，那么 Django 不会提供任何自动事务管理，中间件不会隐式提交事务，你得
完全自己管理事务，甚至需要在其他地方使用中间件来提交变动。

因此，全局性停用事务管理适用于你想要运行自己的事务管理中间件的情况下，或者想做
些奇怪的事情的情况下。绝大多数情况下，最好使用缺省的事务行为或使用事务中间件，
根据需要修改函数。

.. _topics-db-transactions-savepoints:

保存点
==========

保存点是事务中的一个标记，可以让你只回滚部分事务，而不是整个事务。
PostgreSQL 8 and Oracle 支持保存点。其他数据库提供保存点功能，但是是空操作，
不做任何事情。

使用 Django 缺省的 ``autocommit`` 行为时，保存点是没用的。但当你使用
``commit_on_success`` 或 ``commit_manually`` 时每个开放事务都会生成一系统数据库
操作，并等待提交或回滚。如果你决定回滚，那么整个事务都会全部回滚。相对于执行
``transaction.rollback()`` 产生的全部回滚，保存点可以提供对回滚的细粒度地控制。

以下每个函数都有一个提供被操作的数据库名称的 ``using`` 参数。如果没有提供这个
参数，那么就会使用 ``"缺省"`` 数据库。

保存点被事务对象上的三个方法控制：

.. method:: transaction.savepoint(using=None)

    创建一个新的保存点。
    Creates a new savepoint. This marks a point in the transaction that
    is known to be in a "good" state.

    Returns the savepoint ID (sid).

.. method:: transaction.savepoint_commit(sid, using=None)

    Updates the savepoint to include any operations that have been performed
    since the savepoint was created, or since the last commit.

.. method:: transaction.savepoint_rollback(sid, using=None)

    Rolls the transaction back to the last point at which the savepoint was
    committed.

The following example demonstrates the use of savepoints::

    from django.db import transaction

    @transaction.commit_manually
    def viewfunc(request):

      a.save()
      # open transaction now contains a.save()
      sid = transaction.savepoint()

      b.save()
      # open transaction now contains a.save() and b.save()

      if want_to_keep_b:
          transaction.savepoint_commit(sid)
          # open transaction still contains a.save() and b.save()
      else:
          transaction.savepoint_rollback(sid)
          # open transaction now contains only a.save()

      transaction.commit()

Transactions in MySQL
=====================

If you're using MySQL, your tables may or may not support transactions; it
depends on your MySQL version and the table types you're using. (By
"table types," we mean something like "InnoDB" or "MyISAM".) MySQL transaction
peculiarities are outside the scope of this article, but the MySQL site has
`information on MySQL transactions`_.

If your MySQL setup does *not* support transactions, then Django will function
in auto-commit mode: Statements will be executed and committed as soon as
they're called. If your MySQL setup *does* support transactions, Django will
handle transactions as explained in this document.

.. _information on MySQL transactions: http://dev.mysql.com/doc/refman/5.0/en/sql-syntax-transactions.html

Handling exceptions within PostgreSQL transactions
==================================================

When a call to a PostgreSQL cursor raises an exception (typically
``IntegrityError``), all subsequent SQL in the same transaction will fail with
the error "current transaction is aborted, queries ignored until end of
transaction block". Whilst simple use of ``save()`` is unlikely to raise an
exception in PostgreSQL, there are more advanced usage patterns which
might, such as saving objects with unique fields, saving using the
force_insert/force_update flag, or invoking custom SQL.

There are several ways to recover from this sort of error.

Transaction rollback
--------------------

The first option is to roll back the entire transaction. For example::

    a.save() # Succeeds, but may be undone by transaction rollback
    try:
        b.save() # Could throw exception
    except IntegrityError:
        transaction.rollback()
    c.save() # Succeeds, but a.save() may have been undone

Calling ``transaction.rollback()`` rolls back the entire transaction. Any
uncommitted database operations will be lost. In this example, the changes
made by ``a.save()`` would be lost, even though that operation raised no error
itself.

Savepoint rollback
------------------

If you are using PostgreSQL 8 or later, you can use :ref:`savepoints
<topics-db-transactions-savepoints>` to control the extent of a rollback.
Before performing a database operation that could fail, you can set or update
the savepoint; that way, if the operation fails, you can roll back the single
offending operation, rather than the entire transaction. For example::

    a.save() # Succeeds, and never undone by savepoint rollback
    try:
        sid = transaction.savepoint()
        b.save() # Could throw exception
        transaction.savepoint_commit(sid)
    except IntegrityError:
        transaction.savepoint_rollback(sid)
    c.save() # Succeeds, and a.save() is never undone

In this example, ``a.save()`` will not be undone in the case where
``b.save()`` raises an exception.

Database-level autocommit
-------------------------

With PostgreSQL 8.2 or later, there is an advanced option to run PostgreSQL
with :doc:`database-level autocommit </ref/databases>`. If you use this option,
there is no constantly open transaction, so it is always possible to continue
after catching an exception. For example::

    a.save() # succeeds
    try:
        b.save() # Could throw exception
    except IntegrityError:
        pass
    c.save() # succeeds

.. note::

    This is not the same as the :ref:`autocommit decorator
    <topics-db-transactions-autocommit>`. When using database level autocommit
    there is no database transaction at all. The ``autocommit`` decorator
    still uses transactions, automatically committing each transaction when
    a database modifying operation occurs.
