==================
使用表单
==================

.. admonition:: 关于本文

    本文只是 Django 表单处理功能的一个介绍。更深入的细节参见
    :doc:`/ref/forms/api` 、 :doc:`/ref/forms/fields` 和
    :doc:`/ref/forms/validation` 。

.. highlightlang:: html+django

``django.forms`` 是 Django 的表单处理库。

虽然只使用 :class:`~django.http.HttpRequest` 也能处理表单，但是使用表单库可以
更好的完成相关的一系列表单工作。如：

    1. 显示一个包含自动生成的表单控件的表单。
    2. 根据一套规则校验表单提交的数据。
    3. 在校验出错时重新显示一个表单。
    4. 把提交的数据转换为相应的 Python 数据类型。

概述
========

本库涉及以下概念：

.. glossary::

    控件
        一个相当于 HTML 表单控件（如 ``<input type="text">`` 或 ``<textarea>``
        ）的类。这个类负责把控件渲染成 HTML 。

    字段
        一个可以用于验证的类。如一个 ``EmailField`` 字段可以保证其数据是一个
        合法的电子邮件地址。

    表单
        一个知道如何验证自己的数据并且能够以 HTML 显示自己的字段的集合。

    表单媒体
        渲染一个表单时需要的 CSS 和 JavaScript 资源。

本库与其他 Django 组件（如数据库层、视图和模板）是不挂钩的。本库只依赖 Django
设置、几个 ``django.utils`` 助手和 Django 的国际化钩子（但是在使用本库时你不
一定要用到国际化功能）。

表单对象
============

一个表单对象封装了一系列表单字段和一套验证规则。表单对象继承自
``django.forms.Form`` 。如果你熟悉 Django 数据库模型，你会发现表单对象的声明
形式与数据库模型的形式相似。

例如，假设有在一个个人网站上有一个用于实现”与我联系“功能的表单：

.. code-block:: python

    from django import forms

    class ContactForm(forms.Form):
        subject = forms.CharField(max_length=100)
        message = forms.CharField()
        sender = forms.EmailField()
        cc_myself = forms.BooleanField(required=False)

一个表单由 ``Field`` 对象组成。上例中，我们的表单包含四个字段：
``subject`` 、 ``message`` 、 ``sender`` 和 ``cc_myself`` 。 ``CharField`` 、
``EmailField`` 和 ``BooleanField`` 是三种验证字段（完整列表详见
:doc:`/ref/forms/fields` ）。

如果你的表单准备用于直接增加或编辑一个 Django 模型，你可以使用
:doc:`ModelForm </topics/forms/modelforms>` ，这样可以避免重复你的模型定义。

在视图中使用表单
----------------------

在视图中使用表单的标准模式如下：

.. code-block:: python

   def contact(request):
       if request.method == 'POST': # 如果表单已被提交...
           form = ContactForm(request.POST) # 一个表单绑定到提交的数据
           if form.is_valid(): # 通过所有的验证规则
               # 在 form.cleaned_data 中加工数据
               # ...
               return HttpResponseRedirect('/thanks/') # 在提交后重定向
       else:
           form = ContactForm() # 一个未绑定的表单

       return render_to_response('contact.html', {
           'form': form,
       })

主要分三步：

    1. 如果表单还没提交，一个未绑定的 ContactForm 实例被创建并传递给模板。
    2. 如果表单已经提交，会使用 ``request.POST`` 创建一个绑定的表单实例。如果
       提交的数据验证通过，就会继续下去，用户会被重定向到 "thanks" 页面。
    3. 如果提交的表单没有通过验证，绑定的表单实例会传递给模板。

**绑定** 和 **未绑定** 表单之间的区别很重要。一个未绑定表单没有与之关联的数据。
当渲染给用户时，会出现空值或缺省值。一个绑定表单有提交的数据，因此可以用于被
验证数据。如果一个不合法的绑定表单被渲染，那么会包含内联错误信息用以告知用户
哪里出错了。

关于绑定和未绑定表单之间的区别更进一步的内容，参见
:ref:`ref-forms-api-bound-unbound` 。

用表单处理文件上传
---------------------------------

用表单处理文件上传参见 :ref:`binding-uploaded-files` 。

处理表单中的数据
-------------------------------

一旦 ``is_valid()`` 返回 ``True`` ，你就可以认为数据符合表单的验证规则，可以
安全提交了。这时，与其直接操作 ``request.POST`` 不如操作 ``form.cleaned_data`` 。
因为它不仅给过了验证还已经被转换为相应的 Python 类型。如在上例中， ``cc_myself``
将会是一个布尔值。同理， ``IntegerField`` 和 ``FloatField`` 这类的字段会转换为
相应的 Python int 和 float 类型。注意，只读字段不能使用 ``form.cleaned_data``
（并且在自定义 ``clean()`` 方法中设置一个值是无效的），因为这些字段会被显示为
本文而不是输入元素，它们不会被提交回服务器。

扩展上面的例子，举例说明表单数据是如何处理的：

.. code-block:: python

    if form.is_valid():
        subject = form.cleaned_data['subject']
        message = form.cleaned_data['message']
        sender = form.cleaned_data['sender']
        cc_myself = form.cleaned_data['cc_myself']

        recipients = ['info@example.com']
        if cc_myself:
            recipients.append(sender)

        from django.core.mail import send_mail
        send_mail(subject, message, sender, recipients)
        return HttpResponseRedirect('/thanks/') # 在提交后重定向

关于更多在 Django 中发送电子邮件的内容，参见 :doc:`/topics/email` 。

使用模板显示一个表单
----------------------------------

表间被设计与 Django 模板一起工作。在上面的例子中，我们通过环境变量 ``form`` 把
``ContactForm`` 实例传递给了模板。以下是一个简单的例子模板::

    <form action="/contact/" method="post">{% csrf_token %}
    {{ form.as_p }}
    <input type="submit" value="Submit" />
    </form>

表单只输出它自己的字段，因此必须由你提供其周围相应的 ``<form>`` 标记和提交按钮。

.. admonition:: 表单和跨站请求伪造保护

   Django 自带一个易用的 :doc:`跨站请求伪造保护机制 </ref/contrib/csrf>` 。在
   上面的例子中，当在保护机制下使用 POST 提交一个表单时你必须使用
   :ttag:`csrf_token` 模板标记。但是，这种保护机制没有直接与表单相关联，那么在
   本文下面的例子中均省略这个标记。

``form.as_p`` 输了每一个表单字段并用 label 和 p HTML 标记来包围。上文的例子模板
输出如下::

   <form action="/contact/" method="post">
   <p><label for="id_subject">Subject:</label>
       <input id="id_subject" type="text" name="subject" maxlength="100" /></p>
   <p><label for="id_message">Message:</label>
       <input type="text" name="message" id="id_message" /></p>
   <p><label for="id_sender">Sender:</label>
       <input type="text" name="sender" id="id_sender" /></p>
   <p><label for="id_cc_myself">Cc myself:</label>
       <input type="checkbox" name="cc_myself" id="id_cc_myself" /></p>
   <input type="submit" value="Submit" />
   </form>

注意，每个表单字段都有一个设置为 ``id_<field-name>`` 的 ID 属性，这个属性被相应
的 label 标记引用。这一点对于保证表单易于被辅助技术（如屏幕阅读软件）操作是很
重要的。你也可以 :ref:`定制 label 和 id 产生的方式
<ref-forms-api-configuring-label>` 。

你还可以使用 ``form.as_table`` 来输了表格行（你得自行提供自己的 ``<table>``
标记），使用 ``form.as_ul`` 来输出列表项。

定制表单模板
-----------------------------

如果缺省产生的 HTML 不合你的胃口，那么你可以使用 Django 模板语言定制输出表单。
我们来扩展上面的例子::

    <form action="/contact/" method="post">
        {{ form.non_field_errors }}
        <div class="fieldWrapper">
            {{ form.subject.errors }}
            <label for="id_subject">E-mail subject:</label>
            {{ form.subject }}
        </div>
        <div class="fieldWrapper">
            {{ form.message.errors }}
            <label for="id_message">Your message:</label>
            {{ form.message }}
        </div>
        <div class="fieldWrapper">
            {{ form.sender.errors }}
            <label for="id_sender">Your email address:</label>
            {{ form.sender }}
        </div>
        <div class="fieldWrapper">
            {{ form.cc_myself.errors }}
            <label for="id_cc_myself">CC yourself?</label>
            {{ form.cc_myself }}
        </div>
        <p><input type="submit" value="Send message" /></p>
    </form>

每个已命名的表单字段可以用 ``{{ form.name_of_field }}`` 输出到模板。
 ``{{ form.name_of_field }}`` 会产生需要显示的 HTML 控件。使用
``{{ form.name_of_field.errors }}`` 可以显示一个无序表单错误列表，其输也可能
如下::

   <ul class="errorlist">
       <li>Sender is required.</li>
   </ul>

这个列表有一个 ``errorlist`` CSS 样式，可用于定制其表现形式。如果你要更进一步
定制错误显示样式，你可以通过循环遍历错误实现::

    {% if form.subject.errors %}
        <ol>
        {% for error in form.subject.errors %}
            <li><strong>{{ error|escape }}</strong></li>
        {% endfor %}
        </ol>
    {% endif %}

遍历表单字段
------------------------------

如果你的表单字段都使用相同的 HTML ，那么你可以通过使用一个 ``{% for %}`` 循环来
减少重复代码::

    <form action="/contact/" method="post">
        {% for field in form %}
            <div class="fieldWrapper">
                {{ field.errors }}
                {{ field.label_tag }}: {{ field }}
            </div>
        {% endfor %}
        <p><input type="submit" value="Send message" /></p>
    </form>

在这个循环中， ``{{ field }}`` 是一个 :class:`BoundField` 的实例。
``BoundField`` 还有以下在模板十分有用的属性：

    ``{{ field.label }}``
        The label of the field, e.g. ``E-mail address``.

    ``{{ field.label_tag }}``
        The field's label wrapped in the appropriate HTML ``<label>`` tag,
        e.g. ``<label for="id_email">E-mail address</label>``

    ``{{ field.html_name }}``
        The name of the field that will be used in the input element's name
        field. This takes the form prefix into account, if it has been set.

    ``{{ field.help_text }}``
        Any help text that has been associated with the field.

    ``{{ field.errors }}``
        Outputs a ``<ul class="errorlist">`` containing any validation errors
        corresponding to this field. You can customize the presentation of
        the errors with a ``{% for error in field.errors %}`` loop. In this
        case, each object in the loop is a simple string containing the error
        message.

    ``field.is_hidden``
        This attribute is ``True`` if the form field is a hidden field and
        ``False`` otherwise. It's not particularly useful as a template
        variable, but could be useful in conditional tests such as::

            {% if field.is_hidden %}
               {# Do something special #}
            {% endif %}

Looping over hidden and visible fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're manually laying out a form in a template, as opposed to relying on
Django's default form layout, you might want to treat ``<input type="hidden">``
fields differently than non-hidden fields. For example, because hidden fields
don't display anything, putting error messages "next to" the field could cause
confusion for your users -- so errors for those fields should be handled
differently.

Django provides two methods on a form that allow you to loop over the hidden
and visible fields independently: ``hidden_fields()`` and
``visible_fields()``. Here's a modification of an earlier example that uses
these two methods::

    <form action="/contact/" method="post">
        {% for field in form.visible_fields %}
            <div class="fieldWrapper">

                {# Include the hidden fields in the form #}
                {% if forloop.first %}
                    {% for hidden in form.hidden_fields %}
                    {{ hidden }}
                    {% endfor %}
                {% endif %}

                {{ field.errors }}
                {{ field.label_tag }}: {{ field }}
            </div>
        {% endfor %}
        <p><input type="submit" value="Send message" /></p>
    </form>

This example does not handle any errors in the hidden fields. Usually, an
error in a hidden field is a sign of form tampering, since normal form
interaction won't alter them. However, you could easily insert some error
displays for those form errors, as well.

Reusable form templates
-----------------------

If your site uses the same rendering logic for forms in multiple places, you
can reduce duplication by saving the form's loop in a standalone template and
using the :ttag:`include` tag to reuse it in other templates::

    <form action="/contact/" method="post">
        {% include "form_snippet.html" %}
        <p><input type="submit" value="Send message" /></p>
    </form>

    # In form_snippet.html:

    {% for field in form %}
        <div class="fieldWrapper">
            {{ field.errors }}
            {{ field.label_tag }}: {{ field }}
        </div>
    {% endfor %}

If the form object passed to a template has a different name within the
context, you can alias it using the ``with`` argument of the :ttag:`include`
tag::

    <form action="/comments/add/" method="post">
        {% include "form_snippet.html" with form=comment_form %}
        <p><input type="submit" value="Submit comment" /></p>
    </form>

If you find yourself doing this often, you might consider creating a custom
:ref:`inclusion tag<howto-custom-template-tags-inclusion-tags>`.

Further topics
==============

This covers the basics, but forms can do a whole lot more:

.. toctree::
   :maxdepth: 2

   formsets
   modelforms
   media

.. seealso::

    :doc:`The Forms Reference </ref/forms/index>`
        Covers the full API reference, including form fields, form widgets,
        and form and field validation.
