==========================
根据模型创建表单
==========================

.. module:: django.forms.models
   :synopsis: ModelForm and ModelFormset.

.. currentmodule:: django.forms

``ModelForm``
=============
.. class:: ModelForm

如果你正在编写一个数据库驱动的应用，那么你很可能需要一个与模型紧密联系的表单。
例如，假设你有一个 ``博客评论`` 模型，那么你就可能需要创建一个用于填写用户评论
的表单。在这种情况下，在表单中定义字段类型就显得多余了，因为在模型中已经对字段
作了定义。

因此， Django 提供一个可以根据模型来创建 ``表单`` 类的辅助类。

例如::

    >>> from django.forms import ModelForm

    # 创建表单类。
    >>> class ArticleForm(ModelForm):
    ...     class Meta:
    ...         model = Article

    # 创建一个表单来添加一篇文章。
    >>> form = ArticleForm()

    # 创建一个表单来修改一篇已存在的文章。
    >>> article = Article.objects.get(pk=1)
    >>> form = ArticleForm(instance=article)

字段类型
-----------

被创建的 ``表单`` 类会根据每个模型字段创建相应的表单字段。每种模型字段都有相应
缺省的表单字段。例如，模型中的 ``CharField`` 字段对应于表单中的 ``CharField``
字段，模型中的 ``ManyToManyField`` 字段对应表单中的 ``MultipleChoiceField``
字段。以下是字段对应的列表：

    ===============================  ========================================
    模型字段                         表单字段
    ===============================  ========================================
    ``AutoField``                    在表单中不出现

    ``BigIntegerField``              ``IntegerField`` ， ``min_value`` 为
                                     -9223372036854775808 且 ``max_value``
                                     为 9223372036854775807 。

    ``BooleanField``                 ``BooleanField``

    ``CharField``                    ``CharField`` ， ``max_length`` 设置为
                                     模型字段的 ``max_length``

    ``CommaSeparatedIntegerField``   ``CharField``

    ``DateField``                    ``DateField``

    ``DateTimeField``                ``DateTimeField``

    ``DecimalField``                 ``DecimalField``

    ``EmailField``                   ``EmailField``

    ``FileField``                    ``FileField``

    ``FilePathField``                ``CharField``

    ``FloatField``                   ``FloatField``

    ``ForeignKey``                   ``ModelChoiceField`` （参见下文）

    ``ImageField``                   ``ImageField``

    ``IntegerField``                 ``IntegerField``

    ``IPAddressField``               ``IPAddressField``

    ``ManyToManyField``              ``ModelMultipleChoiceField`` （参见下文）

    ``NullBooleanField``             ``CharField``

    ``PhoneNumberField``             ``USPhoneNumberField``
                                     （源于 ``django.contrib.localflavor.us`` ）

    ``PositiveIntegerField``         ``IntegerField``

    ``PositiveSmallIntegerField``    ``IntegerField``

    ``SlugField``                    ``SlugField``

    ``SmallIntegerField``            ``IntegerField``

    ``TextField``                    ``CharField`` ， ``widget=forms.Textarea``

    ``TimeField``                    ``TimeField``

    ``URLField``                     ``URLField`` ， ``verify_exists`` 与
                                     模型字段的 ``verify_exists`` 相同
    ===============================  ========================================

.. versionadded:: 1.2
    ``BigIntegerField`` 是 Django 1.2 中新增的。


正如你所期待的， ``ForeignKey`` 和 ``ManyToManyField`` 模型字段是特殊的::

    * ``ForeignKey`` 对应 ``django.forms.ModelChoiceField`` ，是一个选项为模型
      ``查询集`` 的 ``ChoiceField`` 。

    * ``ManyToManyField`` 对应 ``django.forms.ModelMultipleChoiceField`` ，是
      一个选项为模型 ``查询集`` 的 ``MultipleChoiceField`` 。

另外，每个被创建的表单字段都包含按下列方式设置的属性：

    * 如果模型字段有 ``blank=True`` ，那么表单字段的 ``required`` 设置为
      ``False`` ，否则设置为 ``required=True`` 。

    * 表单字段的 ``label`` 设置为模型字段的 ``verbose_name`` ，且首字母大写。

    * 表单字段的 ``help_text`` 设置为模型字段的 ``help_text`` 。

    * 如果模型字段有 ``choices`` 集，那么表单字段的 ``widget`` 会被设置为
      ``Select`` ，选项来自于模型字段的 ``choices`` 。选项一般会包含一个空白
      选项，并把这个空白选项作为缺省值。如果这个字段是必填项，那么就会限制用户
      必须选择一个选项。如果模型字段有 ``blank=False`` 属性并且有一个显示定义
      的 ``缺省值`` ，那么选项中就不会包含空白选项。（ ``缺省值`` 会在初始化时
      被选中。）

最后，请注意你可以重载给定模型字段相对应的表单字段。参见下面
`重载缺省的字段类型和控件`_ 。

一个完整的例子
--------------

假设有如下的模型::

    from django.db import models
    from django.forms import ModelForm

    TITLE_CHOICES = (
        ('MR', 'Mr.'),
        ('MRS', 'Mrs.'),
        ('MS', 'Ms.'),
    )

    class Author(models.Model):
        name = models.CharField(max_length=100)
        title = models.CharField(max_length=3, choices=TITLE_CHOICES)
        birth_date = models.DateField(blank=True, null=True)

        def __unicode__(self):
            return self.name

    class Book(models.Model):
        name = models.CharField(max_length=100)
        authors = models.ManyToManyField(Author)

    class AuthorForm(ModelForm):
        class Meta:
            model = Author

    class BookForm(ModelForm):
        class Meta:
            model = Book

依据以上模型，其中的 ``ModelForm`` 子类大致与以下的类相等。（唯一的区别在于
``save()`` 方法，这点稍后再谈）::

    class AuthorForm(forms.Form):
        name = forms.CharField(max_length=100)
        title = forms.CharField(max_length=3,
                    widget=forms.Select(choices=TITLE_CHOICES))
        birth_date = forms.DateField(required=False)

    class BookForm(forms.Form):
        name = forms.CharField(max_length=100)
        authors = forms.ModelMultipleChoiceField(queryset=Author.objects.all())

``is_valid()`` 方法和 ``errors``
----------------------------------------

.. versionchanged:: 1.2

第一次调用 ``is_valid()`` 或操作一个 ``ModelForm`` 的 ``errors`` 属性时总是会
触发表单验证，但是在 Django 1.2 版本中还会触发
:ref:`模型验证 <validating-objects>` 。这样会产生副作用：清理传递给
``ModelForm`` 构造器的模型。例如，在表单中调用 ``is_valid()`` 会把模型中所有
日期字段转换为真正在日期对象。

``save()`` 方法
---------------------

每个由 ``ModelForm`` 产生的表单都有一个 ``save()`` 方法，这个方法根据绑定到表单
的数据创建和保存数据库对象。一个 ``ModelForm`` 子类可以接受一个已存在的模型实例
作为关键字参数 ``instance`` 。如果实例存在，那么 ``save()`` 方法会更新这个实例；
否则会创建一个新的指定模型的实例::

    # 根据 POST 数据创建一个表单实例。
    >>> f = ArticleForm(request.POST)

    # 根据表单数据保存一个新文章对象。
    >>> new_article = f.save()

    # 创建一个表单来编辑已存在的文章。
    >>> a = Article.objects.get(pk=1)
    >>> f = ArticleForm(instance=a)
    >>> f.save()

    # 创建一个表单来编辑已存在的文章，但是使用 POST 数据来生成表单。
    >>> a = Article.objects.get(pk=1)
    >>> f = ArticleForm(request.POST, instance=a)
    >>> f.save()

注意，如果表单数据未通过验证，那么 ``save()`` 会引发一个 ``ValueError`` 。例如，
如果 form.errors 为 True ，那么就会引发。

``save()`` 方法接受一个可选关键字参数 ``commit`` ，这个参数要么是 ``True`` ，
要么是 ``False`` 。如果使用 ``commit=False`` 来调用 ``save()`` ，那么会返回一个
还没有被保存到数据库的对象。在这种情况下你可以自由决定如何调用 ``save()`` 方法。
这种情况主要用于在保存数据之前需要作一些处理的场合下，或者需要使用特殊的
:ref:`模型保存选项 <ref-models-force-insert>` 的场合下。 ``commit`` 缺省为
``True`` 。

当模型与另一个模型有多对多关系时，使用 ``commit=False`` 会产生副作用。在这种
情况下，当保存表单时， Django 不会立即保存为多对多关系的表单数据。这是因为当
数据没有保存进数据时是不可能为实例保存多对多数据的。

为了解决这个问题，每次当使用 ``commit=False`` 保存表单时， Django 会为
``ModelForm`` 子类增加一个 ``save_m2m()`` 方法。当手动保存表单产生的实例之后，
可以执行 ``save_m2m()`` 来保存多对多表单数据。例如::

    # 根据 POST 数据创建一个表单实例。
    >>> f = AuthorForm(request.POST)

    # 创建，但不保存新的作者实例。
    >>> new_author = f.save(commit=False)

    # 对作者作一定的修改。
    >>> new_author.some_field = 'some_value'

    # 保存新的实例。
    >>> new_author.save()

    # 现在，保存表单的多对多数据。
    >>> f.save_m2m()

只有当你使用 ``save(commit=False)`` 时才需要调用 ``save_m2m()`` 。如果你只是
使用一个简单的 ``save()`` ，那么表单的所有数据，包括多对多数据都会被保存，不
需要额外的调用其他方法。例如::

    # 根据 POST 数据创建一个表单实例。
    >>> a = Author()
    >>> f = AuthorForm(request.POST, instance=a)

    # 创建并保存新的作者实例。万事大吉。
    >>> new_author = f.save()

除子 ``save()`` 和 ``save_m2m()`` 方法， ``ModelForm`` 与其他表单完全一样。
例如， ``is_valid()`` 方法用于表单验证， ``is_multipart()`` 方法用于决定表单
是否需要多部分文件上传（亦决定是否必须向表单传递 ``request.FILES`` ），等等。
详见 :ref:`binding-uploaded-files` 。 

使用表单字段的子集
------------------------------------

在某些情况下，在表单中你可能只要使用所有模型字段中的一部分，即模型字段的子集。
有三种方法可以告诉 ``ModelForm`` 只使用模型字段的子集：

1. 在模型字段上设置 ``editable=False`` ，这样任何由 ``ModelForm`` 创建的表单都
   不会包含这个字段。

2. 使用 ``ModelForm`` 的内部 ``Meta`` 类的 ``fields`` 属性。这个属性应当是一个
   表单中要包含的字段的列表。这个列表决定表单中要出现哪些字段和这些字段的出场
   顺序。

3. 使用 ``ModelForm`` 的内部 ``Meta`` 类的 ``exclude`` 属性。这个属性应当是
   一个表单中要包含的字段的列表。如果定义了这个属性，那么列表中的字段就会被表单
   排除。

例如，你要一个 ``Author`` 模型（前文已定义）的相关表单，但是只包含 ``name`` 和
``title`` ，那么可以这样定义 ``fields`` 或 ``exclude`` ::

    class PartialAuthorForm(ModelForm):
        class Meta:
            model = Author
            fields = ('name', 'title')

    class PartialAuthorForm(ModelForm):
        class Meta:
            model = Author
            exclude = ('birth_date',)

因为作者模型只有三个字段： 'name' 、 'title' 和 'birth_date' ，所以上述两个表单
包含完全相同的字段。

.. note::

    当你用 ``ModelForm`` 创建一个表单时，如果定义了 ``fields`` 和 ``exclude`` ，
    那么在被创建的表单中没有出现的字段就不会被表单的 ``save()`` 保存。 Django
    不允许保存一个不完整的模型，因此如果模型有字段不允许为空，但是又没有为这个
    字段设置缺省值，当试图 ``save()`` 一个 ``ModelForm`` 时就会失败。为避免这种
    情况发生，模型中的必填字段应当在初始化时赋值::

        author = Author(title='Mr')
        form = PartialAuthorForm(request.POST, instance=author)
        form.save()

    或者你可以使用 ``save(commit=False)`` 并手动设置额外的必填字段::

        form = PartialAuthorForm(request.POST)
        author = form.save(commit=False)
        author.title = 'Mr'
        author.save()

    关于如何使用 ``save(commit=False)`` ，详见本文 `保存表单一节`_ 。

.. _保存表单一节: `save() 方法`_

重载缺省的字段类型和控件
---------------------------------------------

.. versionadded:: 1.2
 	``widgets`` 属性是 Django 1.2 版本新增的。

前文中提到缺省的 `字段类型`_ 一般是比较明智的。如果在模型有一个字段是
``DateField`` 那么一般在表单中就应该对应 ``DateField`` 。但是，
``ModelForm`` 是非常灵活的，你可以自己改变模型字段对应的表单字段类型和控件。

使用表单类内置的 ``Meta`` 类的 ``widgets`` 属性可以自定义表单控件。这个属性应当
是一个字段名和控件类或实例相对应的字典。

例如，假设 ``Author`` 的 ``name`` 是一个 ``CharField`` ，你想要把原来缺省对应的
``<input type="text">`` 改变为 ``<textarea>`` ，可以这样来重载控件::

    from django.forms import ModelForm, Textarea

    class AuthorForm(ModelForm):
        class Meta:
            model = Author
            fields = ('name', 'title', 'birth_date')
            widgets = {
                'name': Textarea(attrs={'cols': 80, 'rows': 20}),
            }

``widgets`` 字典可以接受控件实例（如： ``Textarea(...)`` ），也可以接受类（如：
``Textarea`` ）。

如果你想要更进一步自定义一个字段，包括它的类型或标签等等，那么可以像一般的
表单类一样声明指定字段。声明的字段会重载 ``model`` 属性产生的缺省的字段。

例如，假设想要对 ``pub_date`` 使用 ``MyDateFormField`` ，可以如下操作::

    class ArticleForm(ModelForm):
        pub_date = MyDateFormField()

        class Meta:
            model = Article

如何想要重载一个字段的缺省标签，可以在声明表单字段时指定 ``label`` 参数::

   >>> class ArticleForm(ModelForm):
   ...     pub_date = DateField(label='Publication date')
   ...
   ...     class Meta:
   ...         model = Article

.. note::

    如果你象这样显示地初始化一个表单字段，那么 Django 会假定你想要完全自定义其
    行为，因此该字段的缺省属性（如 ``max_length`` 和 ``require`` ）就不会从模型
    中转移过来。如果你想要获得模型中定义的相关行为，那么就必须在声明表单字段时
    显示地定义。

    例如，有如下 ``Article`` 模型::

        class Article(models.Model):
            headline = models.CharField(max_length=200, null=True, blank=True,
                                        help_text="Use puns liberally")
            content = models.TextField()

    你要对 ``headline`` 做一些自定义的验证，同时又想保持 ``blank`` 和
    ``help_text`` 和模型中定义的一致，就应当这样定义 ``ArticleForm``::

        class ArticleForm(ModelForm):
            headline = MyFormField(max_length=200, required=False,
                                   help_text="Use puns liberally")

            class Meta:
                model = Article

    关于字段及其参数详见 :doc:`表单字段文档 </ref/forms/fields>` 。

改变字段的顺序
----------------------------

By default, a ``ModelForm`` will render fields in the same order that they are
defined on the model, with ``ManyToManyField`` instances appearing last. If
you want to change the order in which fields are rendered, you can use the
``fields`` attribute on the ``Meta`` class.

The ``fields`` attribute defines the subset of model fields that will be
rendered, and the order in which they will be rendered. For example given this
model::

    class Book(models.Model):
        author = models.ForeignKey(Author)
        title = models.CharField(max_length=100)

the ``author`` field would be rendered first. If we wanted the title field
to be rendered first, we could specify the following ``ModelForm``::

    >>> class BookForm(ModelForm):
    ...     class Meta:
    ...         model = Book
    ...         fields = ('title', 'author')

.. _overriding-modelform-clean-method:

Overriding the clean() method
-----------------------------

You can override the ``clean()`` method on a model form to provide additional
validation in the same way you can on a normal form.

In this regard, model forms have two specific characteristics when compared to
forms:

By default the ``clean()`` method validates the uniqueness of fields that are
marked as ``unique``, ``unique_together`` or ``unique_for_date|month|year`` on
the model.  Therefore, if you would like to override the ``clean()`` method and
maintain the default validation, you must call the parent class's ``clean()``
method.

Also, a model form instance bound to a model object will contain a
``self.instance`` attribute that gives model form methods access to that
specific model instance.

Form inheritance
----------------

As with basic forms, you can extend and reuse ``ModelForms`` by inheriting
them. This is useful if you need to declare extra fields or extra methods on a
parent class for use in a number of forms derived from models. For example,
using the previous ``ArticleForm`` class::

    >>> class EnhancedArticleForm(ArticleForm):
    ...     def clean_pub_date(self):
    ...         ...

This creates a form that behaves identically to ``ArticleForm``, except there's
some extra validation and cleaning for the ``pub_date`` field.

You can also subclass the parent's ``Meta`` inner class if you want to change
the ``Meta.fields`` or ``Meta.excludes`` lists::

    >>> class RestrictedArticleForm(EnhancedArticleForm):
    ...     class Meta(ArticleForm.Meta):
    ...         exclude = ('body',)

This adds the extra method from the ``EnhancedArticleForm`` and modifies
the original ``ArticleForm.Meta`` to remove one field.

There are a couple of things to note, however.

 * Normal Python name resolution rules apply. If you have multiple base
   classes that declare a ``Meta`` inner class, only the first one will be
   used. This means the child's ``Meta``, if it exists, otherwise the
   ``Meta`` of the first parent, etc.

 * For technical reasons, a subclass cannot inherit from both a ``ModelForm``
   and a ``Form`` simultaneously.

Chances are these notes won't affect you unless you're trying to do something
tricky with subclassing.

Interaction with model validation
---------------------------------

As part of its validation process, ``ModelForm`` will call the ``clean()``
method of each field on your model that has a corresponding field on your form.
If you have excluded any model fields, validation will not be run on those
fields. See the :doc:`form validation </ref/forms/validation>` documentation
for more on how field cleaning and validation work. Also, your model's
``clean()`` method will be called before any uniqueness checks are made. See
:ref:`Validating objects <validating-objects>` for more information on the
model's ``clean()`` hook.

.. _model-formsets:

Model formsets
==============

Like :doc:`regular formsets </topics/forms/formsets>`, Django provides a couple
of enhanced formset classes that make it easy to work with Django models. Let's
reuse the ``Author`` model from above::

    >>> from django.forms.models import modelformset_factory
    >>> AuthorFormSet = modelformset_factory(Author)

This will create a formset that is capable of working with the data associated
with the ``Author`` model. It works just like a regular formset::

    >>> formset = AuthorFormSet()
    >>> print formset
    <input type="hidden" name="form-TOTAL_FORMS" value="1" id="id_form-TOTAL_FORMS" /><input type="hidden" name="form-INITIAL_FORMS" value="0" id="id_form-INITIAL_FORMS" /><input type="hidden" name="form-MAX_NUM_FORMS" id="id_form-MAX_NUM_FORMS" />
    <tr><th><label for="id_form-0-name">Name:</label></th><td><input id="id_form-0-name" type="text" name="form-0-name" maxlength="100" /></td></tr>
    <tr><th><label for="id_form-0-title">Title:</label></th><td><select name="form-0-title" id="id_form-0-title">
    <option value="" selected="selected">---------</option>
    <option value="MR">Mr.</option>
    <option value="MRS">Mrs.</option>
    <option value="MS">Ms.</option>
    </select></td></tr>
    <tr><th><label for="id_form-0-birth_date">Birth date:</label></th><td><input type="text" name="form-0-birth_date" id="id_form-0-birth_date" /><input type="hidden" name="form-0-id" id="id_form-0-id" /></td></tr>

.. note::
    ``modelformset_factory`` uses ``formset_factory`` to generate formsets.
    This means that a model formset is just an extension of a basic formset
    that knows how to interact with a particular model.

Changing the queryset
---------------------

By default, when you create a formset from a model, the formset will use a
queryset that includes all objects in the model (e.g.,
``Author.objects.all()``). You can override this behavior by using the
``queryset`` argument::

    >>> formset = AuthorFormSet(queryset=Author.objects.filter(name__startswith='O'))

Alternatively, you can create a subclass that sets ``self.queryset`` in
``__init__``::

    from django.forms.models import BaseModelFormSet

    class BaseAuthorFormSet(BaseModelFormSet):
        def __init__(self, *args, **kwargs):
            super(BaseAuthorFormSet, self).__init__(*args, **kwargs)
            self.queryset = Author.objects.filter(name__startswith='O')

Then, pass your ``BaseAuthorFormSet`` class to the factory function::

    >>> AuthorFormSet = modelformset_factory(Author, formset=BaseAuthorFormSet)

If you want to return a formset that doesn't include *any* pre-existing
instances of the model, you can specify an empty QuerySet::

   >>> AuthorFormSet(queryset=Author.objects.none())


Controlling which fields are used with ``fields`` and ``exclude``
-----------------------------------------------------------------

By default, a model formset uses all fields in the model that are not marked
with ``editable=False``. However, this can be overridden at the formset level::

    >>> AuthorFormSet = modelformset_factory(Author, fields=('name', 'title'))

Using ``fields`` restricts the formset to use only the given fields.
Alternatively, you can take an "opt-out" approach, specifying which fields to
exclude::

    >>> AuthorFormSet = modelformset_factory(Author, exclude=('birth_date',))

.. _saving-objects-in-the-formset:

Saving objects in the formset
-----------------------------

As with a ``ModelForm``, you can save the data as a model object. This is done
with the formset's ``save()`` method::

    # Create a formset instance with POST data.
    >>> formset = AuthorFormSet(request.POST)

    # Assuming all is valid, save the data.
    >>> instances = formset.save()

The ``save()`` method returns the instances that have been saved to the
database. If a given instance's data didn't change in the bound data, the
instance won't be saved to the database and won't be included in the return
value (``instances``, in the above example).

Pass ``commit=False`` to return the unsaved model instances::

    # don't save to the database
    >>> instances = formset.save(commit=False)
    >>> for instance in instances:
    ...     # do something with instance
    ...     instance.save()

This gives you the ability to attach data to the instances before saving them
to the database. If your formset contains a ``ManyToManyField``, you'll also
need to call ``formset.save_m2m()`` to ensure the many-to-many relationships
are saved properly.

.. _model-formsets-max-num:

Limiting the number of editable objects
---------------------------------------

.. versionchanged:: 1.2

As with regular formsets, you can use the ``max_num`` and ``extra`` parameters
to ``modelformset_factory`` to limit the number of extra forms displayed.

``max_num`` does not prevent existing objects from being displayed::

    >>> Author.objects.order_by('name')
    [<Author: Charles Baudelaire>, <Author: Paul Verlaine>, <Author: Walt Whitman>]

    >>> AuthorFormSet = modelformset_factory(Author, max_num=1)
    >>> formset = AuthorFormSet(queryset=Author.objects.order_by('name'))
    >>> [x.name for x in formset.get_queryset()]
    [u'Charles Baudelaire', u'Paul Verlaine', u'Walt Whitman']

If the value of ``max_num`` is greater than the number of existing related
objects, up to ``extra`` additional blank forms will be added to the formset,
so long as the total number of forms does not exceed ``max_num``::

    >>> AuthorFormSet = modelformset_factory(Author, max_num=4, extra=2)
    >>> formset = AuthorFormSet(queryset=Author.objects.order_by('name'))
    >>> for form in formset:
    ...     print form.as_table()
    <tr><th><label for="id_form-0-name">Name:</label></th><td><input id="id_form-0-name" type="text" name="form-0-name" value="Charles Baudelaire" maxlength="100" /><input type="hidden" name="form-0-id" value="1" id="id_form-0-id" /></td></tr>
    <tr><th><label for="id_form-1-name">Name:</label></th><td><input id="id_form-1-name" type="text" name="form-1-name" value="Paul Verlaine" maxlength="100" /><input type="hidden" name="form-1-id" value="3" id="id_form-1-id" /></td></tr>
    <tr><th><label for="id_form-2-name">Name:</label></th><td><input id="id_form-2-name" type="text" name="form-2-name" value="Walt Whitman" maxlength="100" /><input type="hidden" name="form-2-id" value="2" id="id_form-2-id" /></td></tr>
    <tr><th><label for="id_form-3-name">Name:</label></th><td><input id="id_form-3-name" type="text" name="form-3-name" maxlength="100" /><input type="hidden" name="form-3-id" id="id_form-3-id" /></td></tr>

.. versionchanged:: 1.2

A ``max_num`` value of ``None`` (the default) puts no limit on the number of
forms displayed.

Using a model formset in a view
-------------------------------

Model formsets are very similar to formsets. Let's say we want to present a
formset to edit ``Author`` model instances::

    def manage_authors(request):
        AuthorFormSet = modelformset_factory(Author)
        if request.method == 'POST':
            formset = AuthorFormSet(request.POST, request.FILES)
            if formset.is_valid():
                formset.save()
                # do something.
        else:
            formset = AuthorFormSet()
        return render_to_response("manage_authors.html", {
            "formset": formset,
        })

As you can see, the view logic of a model formset isn't drastically different
than that of a "normal" formset. The only difference is that we call
``formset.save()`` to save the data into the database. (This was described
above, in :ref:`saving-objects-in-the-formset`.)

Overiding ``clean()`` on a ``model_formset``
--------------------------------------------

Just like with ``ModelForms``, by default the ``clean()`` method of a
``model_formset`` will validate that none of the items in the formset violate
the unique constraints on your model (either ``unique``, ``unique_together`` or
``unique_for_date|month|year``).  If you want to overide the ``clean()`` method
on a ``model_formset`` and maintain this validation, you must call the parent
class's ``clean`` method::

    class MyModelFormSet(BaseModelFormSet):
        def clean(self):
            super(MyModelFormSet, self).clean()
            # example custom validation across forms in the formset:
            for form in self.forms:
                # your custom formset validation

Using a custom queryset
-----------------------

As stated earlier, you can override the default queryset used by the model
formset::

    def manage_authors(request):
        AuthorFormSet = modelformset_factory(Author)
        if request.method == "POST":
            formset = AuthorFormSet(request.POST, request.FILES,
                                    queryset=Author.objects.filter(name__startswith='O'))
            if formset.is_valid():
                formset.save()
                # Do something.
        else:
            formset = AuthorFormSet(queryset=Author.objects.filter(name__startswith='O'))
        return render_to_response("manage_authors.html", {
            "formset": formset,
        })

Note that we pass the ``queryset`` argument in both the ``POST`` and ``GET``
cases in this example.

Using the formset in the template
---------------------------------

.. highlight:: html+django

There are three ways to render a formset in a Django template.

First, you can let the formset do most of the work::

    <form method="post" action="">
        {{ formset }}
    </form>

Second, you can manually render the formset, but let the form deal with
itself::

    <form method="post" action="">
        {{ formset.management_form }}
        {% for form in formset %}
            {{ form }}
        {% endfor %}
    </form>

When you manually render the forms yourself, be sure to render the management
form as shown above. See the :ref:`management form documentation
<understanding-the-managementform>`.

Third, you can manually render each field::

    <form method="post" action="">
        {{ formset.management_form }}
        {% for form in formset %}
            {% for field in form %}
                {{ field.label_tag }}: {{ field }}
            {% endfor %}
        {% endfor %}
    </form>

If you opt to use this third method and you don't iterate over the fields with
a ``{% for %}`` loop, you'll need to render the primary key field. For example,
if you were rendering the ``name`` and ``age`` fields of a model::

    <form method="post" action="">
        {{ formset.management_form }}
        {% for form in formset %}
            {{ form.id }}
            <ul>
                <li>{{ form.name }}</li>
                <li>{{ form.age }}</li>
            </ul>
        {% endfor %}
    </form>

Notice how we need to explicitly render ``{{ form.id }}``. This ensures that
the model formset, in the ``POST`` case, will work correctly. (This example
assumes a primary key named ``id``. If you've explicitly defined your own
primary key that isn't called ``id``, make sure it gets rendered.)

.. highlight:: python

Inline formsets
===============

Inline formsets is a small abstraction layer on top of model formsets. These
simplify the case of working with related objects via a foreign key. Suppose
you have these two models::

    class Author(models.Model):
        name = models.CharField(max_length=100)

    class Book(models.Model):
        author = models.ForeignKey(Author)
        title = models.CharField(max_length=100)

If you want to create a formset that allows you to edit books belonging to
a particular author, you could do this::

    >>> from django.forms.models import inlineformset_factory
    >>> BookFormSet = inlineformset_factory(Author, Book)
    >>> author = Author.objects.get(name=u'Mike Royko')
    >>> formset = BookFormSet(instance=author)

.. note::
    ``inlineformset_factory`` uses ``modelformset_factory`` and marks
    ``can_delete=True``.

More than one foreign key to the same model
-------------------------------------------

If your model contains more than one foreign key to the same model, you'll
need to resolve the ambiguity manually using ``fk_name``. For example, consider
the following model::

    class Friendship(models.Model):
        from_friend = models.ForeignKey(Friend)
        to_friend = models.ForeignKey(Friend)
        length_in_months = models.IntegerField()

To resolve this, you can use ``fk_name`` to ``inlineformset_factory``::

    >>> FriendshipFormSet = inlineformset_factory(Friend, Friendship, fk_name="from_friend")

Using an inline formset in a view
---------------------------------

You may want to provide a view that allows a user to edit the related objects
of a model. Here's how you can do that::

    def manage_books(request, author_id):
        author = Author.objects.get(pk=author_id)
        BookInlineFormSet = inlineformset_factory(Author, Book)
        if request.method == "POST":
            formset = BookInlineFormSet(request.POST, request.FILES, instance=author)
            if formset.is_valid():
                formset.save()
                # Do something.
        else:
            formset = BookInlineFormSet(instance=author)
        return render_to_response("manage_books.html", {
            "formset": formset,
        })

Notice how we pass ``instance`` in both the ``POST`` and ``GET`` cases.
