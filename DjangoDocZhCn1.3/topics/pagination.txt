==========
分页
==========

.. module:: django.core.paginator
   :synopsis: Classes to help you easily manage paginated data.

Django 提供了一些类来帮助你对数据进行分页，即使用“上一页、下一页”链接，把数据
显示在不同的页面上。这些类都位于 :file:`django/core/paginator.py` 中。

例子
=======

把一个对象列表和每页要显示的对象个数传递给 :class:`Paginator` ，就可以使用分页
的相关方法了::

    >>> from django.core.paginator import Paginator
    >>> objects = ['john', 'paul', 'george', 'ringo']
    >>> p = Paginator(objects, 2)

    >>> p.count
    4
    >>> p.num_pages
    2
    >>> p.page_range
    [1, 2]

    >>> page1 = p.page(1)
    >>> page1
    <Page 1 of 2>
    >>> page1.object_list
    ['john', 'paul']

    >>> page2 = p.page(2)
    >>> page2.object_list
    ['george', 'ringo']
    >>> page2.has_next()
    False
    >>> page2.has_previous()
    True
    >>> page2.has_other_pages()
    True
    >>> page2.next_page_number()
    3
    >>> page2.previous_page_number()
    1
    >>> page2.start_index() # 本页第一个条目的索引值，索引值由 1 开始。
    3
    >>> page2.end_index() # 本页最后一个条目的索引值，索引值由 1 开始。
    4

    >>> p.page(0)
    Traceback (most recent call last):
    ...
    EmptyPage: That page number is less than 1
    >>> p.page(3)
    Traceback (most recent call last):
    ...
    EmptyPage: That page contains no results

.. note::

    注意，传递给 ``Paginator`` 的可以是一个列表、元组、 Djanog ``查询集`` 或者
    任何有 ``count()`` 或 ``__len__()`` 方法的对象。当需要计算对象的数量时，
    ``Paginator`` 会首先尝试调用 ``count()`` ，如果没有 ``count()`` 方法可调用
    就会调用 ``__len__()`` 方法。这样，就可以优先使用效率更高的 ``count()``
    方法。


在视图中使用 ``Paginator``
==============================

下面是一个稍微复杂一点的例子，我们在视图中使用 :class:`Paginator` 来对查询集
进行分页。我们同时给出了视图和相应的模板来演示如何显示数据。这个例子假设有一个
已经导入的 ``Contacts`` 模型。

视图模型如下::

    from django.core.paginator import Paginator, InvalidPage, EmptyPage

    def listing(request):
        contact_list = Contacts.objects.all()
        paginator = Paginator(contact_list, 25) # 每页显示 25 个联系人

        # 确保请求显示的页码是一个整数。否则使用第 1 页。
        try:
            page = int(request.GET.get('page', '1'))
        except ValueError:
            page = 1

        # 如果页码超出了范围，则使用最后一页。
        try:
            contacts = paginator.page(page)
        except (EmptyPage, InvalidPage):
            contacts = paginator.page(paginator.num_pages)

        return render_to_response('list.html', {"contacts": contacts})

在模板 :file:`list.html` 中需要加入相应的导航代码::

    {% for contact in contacts.object_list %}
        {# Each "contact" is a Contact model object. #}
        {{ contact.full_name|upper }}<br />
        ...
    {% endfor %}

    <div class="pagination">
        <span class="step-links">
            {% if contacts.has_previous %}
                <a href="?page={{ contacts.previous_page_number }}">previous</a>
            {% endif %}

            <span class="current">
                Page {{ contacts.number }} of {{ contacts.paginator.num_pages }}.
            </span>

            {% if contacts.has_next %}
                <a href="?page={{ contacts.next_page_number }}">next</a>
            {% endif %}
        </span>
    </div>


``Paginator`` 对象
=====================

:class:`Paginator` 类构造器如下：

.. class:: Paginator(object_list, per_page, orphans=0, allow_empty_first_page=True)

必填参数
------------------

``object_list``
    一个列表、元组、 Djanog ``查询集`` 或者任何有 ``count()`` 或 ``__len__()``
    方法的对象。

``per_page``
    每页最大条目数，不包含孤儿条目（ ``orphans`` 参数说明见下）。

可选参数
------------------

``orphans``
    最后一页的最小条目值，缺省值为零。当你不希望最后一页只有很少的条目时可以
    使用这个参数。如果最后一页的条目数量小于等于 ``orphans`` 时，最后一页的条目
    就会与倒数第二页的条目合并显示，原来的倒数第二页就会变成最后一页。假设有
    23 个条目， ``per_page=10`` 且 ``orphans=3`` ，那么就会分成两页，第一页有十
    个条目，第二页（也是最后一页）有十三个条目。

``allow_empty_first_page``
    第一页是否可以为空。如果本参数值为 ``False`` 且 ``object_list`` 为空，那么
    就会引发一个 ``EmptyPage`` 错误。

方法
-------

.. method:: Paginator.page(number)

    Returns a :class:`Page` object with the given 1-based index. Raises
    :exc:`InvalidPage` if the given page number doesn't exist.

Attributes
----------

.. attribute:: Paginator.count

    The total number of objects, across all pages.

    .. note::

        When determining the number of objects contained in ``object_list``,
        ``Paginator`` will first try calling ``object_list.count()``. If
        ``object_list`` has no ``count()`` method, then ``Paginator`` will
        fallback to using ``object_list.__len__()``. This allows objects, such
        as Django's ``QuerySet``, to use a more efficient ``count()`` method
        when available.

.. attribute:: Paginator.num_pages

    The total number of pages.

.. attribute:: Paginator.page_range

    A 1-based range of page numbers, e.g., ``[1, 2, 3, 4]``.

``InvalidPage`` exceptions
==========================

The ``page()`` method raises ``InvalidPage`` if the requested page is invalid
(i.e., not an integer) or contains no objects. Generally, it's enough to trap
the ``InvalidPage`` exception, but if you'd like more granularity, you can trap
either of the following exceptions:

``PageNotAnInteger``
    Raised when ``page()`` is given a value that isn't an integer.

``EmptyPage``
    Raised when ``page()`` is given a valid value but no objects exist on that
    page.

Both of the exceptions are subclasses of ``InvalidPage``, so you can handle
them both with a simple ``except InvalidPage``.


``Page`` objects
================

.. class:: Page(object_list, number, paginator)

You usually won't construct :class:`Pages <Page>` by hand -- you'll get them
using :meth:`Paginator.page`.


Methods
-------

.. method:: Page.has_next()

    Returns ``True`` if there's a next page.

.. method:: Page.has_previous()

    Returns ``True`` if there's a previous page.

.. method:: Page.has_other_pages()

    Returns ``True`` if there's a next *or* previous page.

.. method:: Page.next_page_number()

    Returns the next page number. Note that this is "dumb" and will return the
    next page number regardless of whether a subsequent page exists.

.. method:: Page.previous_page_number()

    Returns the previous page number. Note that this is "dumb" and will return
    the previous page number regardless of whether a previous page exists.

.. method:: Page.start_index()

    Returns the 1-based index of the first object on the page, relative to all
    of the objects in the paginator's list. For example, when paginating a list
    of 5 objects with 2 objects per page, the second page's :meth:`~Page.start_index`
    would return ``3``.

.. method:: Page.end_index()

    Returns the 1-based index of the last object on the page, relative to all of
    the objects in the paginator's list. For example, when paginating a list of
    5 objects with 2 objects per page, the second page's :meth:`~Page.end_index`
    would return ``4``.

Attributes
----------

.. attribute:: Page.object_list

    The list of objects on this page.

.. attribute:: Page.number

    The 1-based page number for this page.

.. attribute:: Page.paginator

    The associated :class:`Paginator` object.

