==============
URL 分配器
==============

.. module:: django.core.urlresolvers

简洁高效的 URL 设计是高品质 Web 应用的一个重要细节。 Django 可以让你不受框架
限制，按需设计 URL 。

这里没有 ``.php`` 或 ``.cgi`` ，也没有诸如 ``0,2097,1-1-1928,00`` 这之类的垃圾。

请阅读万维网创建者 Tim Berners-Lee 所著的 `出色的 URI 不会改变`_ 。这篇文章极好
地阐述了为什么 URL 必须简洁和可用。

.. _出色的 URI 不会改变: http://www.w3.org/Provider/Style/URI

概述
========

为了设计一个应用的 URL ，你要创建一个简称为 **URLconf** （URL 配置）的 Python
模块。这是模块是纯 Python 的，它是 URL 模式（简单的正则表达式）与 Python
回调函数（视图）之间的简单映射。

这个映射可长可短，可以引用其他映射。并且，因为它是纯 Python 的，所以可以动态
创建。

.. _how-django-processes-a-request:

Django 如何处理一个请求
==============================

当用户向网站请求一个页面时， Django 会以下列策略决定执行哪些 Python 代码： 

    1. Django 首先确定要使用的 root URLconf 模块。通常是
       :setting:`ROOT_URLCONF` 的值，但是如果传入的 ``HttpRequest`` 对象有一个
       ``urlconf`` 属性（由 :ref:`request processing <request-middleware>`
       中间件设置），那么这个属性的值就会代替 :setting:`ROOT_URLCONF` 设置。

    2. Django 载入 Python 模块并且搜索 ``urlpatterns`` 。它应当是一个 Python
       列表，格式为 :func:`django.conf.urls.defaults.patterns` 返回的格式。

    3. Django 按顺序检查每个 URL 模式，直到找到第一个匹配所请求的 URL 的模式。

    4. 一旦找到匹配的模式， Django 导入并调用指定的视图（简单的 Python 函数）。
       视图得到一个 :class:`~django.http.HttpRequest` 作为第一个参数，
       正则表达式中的其他值作为剩余的参数。

例子
=======

示例 URLconf::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('',
        (r'^articles/2003/$', 'news.views.special_case_2003'),
        (r'^articles/(\d{4})/$', 'news.views.year_archive'),
        (r'^articles/(\d{4})/(\d{2})/$', 'news.views.month_archive'),
        (r'^articles/(\d{4})/(\d{2})/(\d+)/$', 'news.views.article_detail'),
    )

说明：

    * ``from django.conf.urls.defaults import *`` 导入相关模块使 ``patterns()``
      函数可用。

    * 把要从 URL 捕获的值放入圆括号中。

    * 没有必要添加前斜杠，因为每个 URL 都有。
      例如用 ``^articles`` ，不用 ``^/articles`` 。

    * 每个正则表达式前的 ``'r'`` 是可选的，推荐使用。它表示一个字符串是
      “原始的”，不包含转义字符。参见 `《深入 Python》中的说明`_ 。

示例请求：

    * ``/articles/2005/03/`` 请求会匹配列表中的第三项。 Django 会调用
      ``news.views.month_archive(request, '2005', '03')`` 函数。

    * ``/articles/2005/3/`` 请求不会匹配任何 URL 模式。因为列表中的项目要求月份
      为两位数字。

    * ``/articles/2003/`` 请求会匹配列表中的第一项，而不会匹配第二项。因为搜索
      是按顺序进行的，第一项已匹配了。通过改变顺序可以象这样插入特殊模式。

    * ``/articles/2003`` 请求不会匹配任何模式，因为所有模式都要求以斜杠结尾。

    * ``/articles/2003/03/3/`` 请求会匹配最后一个模式。 Django 会调用
      ``news.views.article_detail(request, '2003', '03', '3')`` 函数。

.. _《深入 Python》中的说明: http://diveintopython.org/regular_expressions/street_addresses.html#re.matching.2.3

命名组
============

上例中使用 *未命名* 正则表达式组（通过圆括号）捕获 URL 的切片并把切片作为
*positional* 参数传递给视图。更高级的用法是使用 *命名* 正则表达式组来捕获
URL 切片并把切片作为 *关键字* 参数传递给视图。

在 Python 正则表达式中，命名正则表达式组的语法是 ``(?P<name>pattern)`` ，
``name`` 是组的名称 ``pattern`` 是要匹配的模式。

上例以命名组方式重写如下::

    urlpatterns = patterns('',
        (r'^articles/2003/$', 'news.views.special_case_2003'),
        (r'^articles/(?P<year>\d{4})/$', 'news.views.year_archive'),
        (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/$', 'news.views.month_archive'),
        (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/(?P<day>\d+)/$', 'news.views.article_detail'),
    )

这个例子的功用与前一个例子相同，但是有一个小差别：捕获的值是以关键字参数传递给
视图的，而不是位置参数。例如：

    * ``/articles/2005/03/`` 请求会调用
      ``news.views.month_archive(request, year='2005', month='03')`` 函数，而
      不是 ``news.views.month_archive(request, '2005', '03')`` 。

    * ``/articles/2003/03/3/`` 请求会调用
      ``news.views.article_detail(request, year='2003', month='03', day='3')`` 。

在实践中，这样可以你的 URLconfs 明确一些并减少参数位置错误，同时可以在视图中按
不同顺序排列参数。当然，这样也会有一些不够简洁，一些开发者认为命名正则表达式是
丑陋和啰嗦的。

匹配和分组算法
-------------------------------

以下是命名组和未命名组同时存在的情况下 URLconf 的解析算法：

如果存在命名参数，就忽略未命名参数，只使用命名参数。否则就传递未命名参数作为
位置参数。

无论何种情况都会把额外关键字参数作为关键字参数传递。参见下文
“传递额外选项给视图函数”。

URLconf 搜索的依据是什么
=================================

URLconf 搜索的依据是请求的 URL ，把 URL 作为一个一般的 Python 字符串。不包括
GET 或 POST 参数，也不包括域名。

例如，在 ``http://www.example.com/myapp/`` 请求中， URLconf 会搜索 ``myapp/`` 。

在 ``http://www.example.com/myapp/?page=3`` 请求中， URLconf 会搜索 ``myapp/`` 。

URLconf 不考虑请求的方法。换句话说，所有请求方法如 ``POST`` 、 ``GET`` 和
``HEAD`` 等等，如果 URL 相同，那么会路由到相同的函数。

URL 模式变量的语法
==================================

``URL 模式`` 应当是一个 Python 列表，格式为
:func:`django.conf.urls.defaults.patterns` 函数返回的格式。我们总是使用
``patterns()`` 来创建 ``urlpatterns`` 变量。

按惯例会在 URLconf 顶部使用使用 ``from django.conf.urls.defaults import *`` 。
这样就可以使用这些对象了：

.. module:: django.conf.urls.defaults

模式
--------

.. function:: patterns(prefix, pattern_description, ...)

一个包括一个前缀和任意数量 URL 模式的函数，返回一个 Django 需要的 URL 模式列表。

``patterns()`` 的第一个参数是一个字符串 ``前缀`` 。参见下文 `视图前缀`_ 。

剩下的参数必须是以下格式的元组::

    (regular expression, Python callback function [, optional dictionary [, optional name]])

...其中的 ``optional dictionary`` 和 ``optional name`` 是可选的。（参见下文
`传递额外参数给视图函数`_ 。）

.. note::
    因为 `patterns()` 是一个函数，它最多只能有 255 个参数（在这种情况下是指 URL
    模式）。这是所有 Python 函数都有的限制。在实践中这基本不是问题，因为可以
    使用 `include()` 来构建你的 URL 模式。但是万一你遇到了 255 个参数限制，别
    忘了 `patterns()` 返回一个 Python 列表，所以可以拆分列表::

        urlpatterns = patterns('',
            ...
            )
        urlpatterns += patterns('',
            ...
            )

    Python 列表没有项目数量限制，这样就可构建无数个 URL 模式了。唯一的限制是
    一次只能创建 254 个（前缀参数占用了一个）。

url
---

.. function:: url(regex, view, kwargs=None, name=None, prefix='')

可以使用 ``url()`` 函数代替一个元组作为传递给 ``patterns()`` 的一个参数。当想要
指定一个没有额外参数字典的名称时，使用 `url()` 是非常方便的。例如::

    urlpatterns = patterns('',
        url(r'^index/$', index_view, name="main-view"),
        ...
    )

这个函数有五个参数，大多数是可选的::

    url(regex, view, kwargs=None, name=None, prefix='')

``name`` 参数的用途参见 `命名 URL 模式`_ 。

``prefix`` 参数与 ``patterns()`` 的第一个参数是一样的。它只在把一个字符串作为
``view`` 参数传递时有用。

处理 404
----------

.. data:: handler404

一个可调用的视图或一个表示完整 Python 导入路径的字符串，在没有可匹配的 URL 模式
时调用。

缺省情况下，值为 ``'django.views.defaults.page_not_found'`` 。缺省值一般够用了。

.. versionchanged:: 1.2
    以前版本的 Django 只接受代表路径的字符串。

处理 500
----------

.. data:: handler500

一个可调用的视图或一个表示完整 Python 导入路径的字符串，在发生服务器错误时调用。
当视图代码运行出错时会发生服务器错误。

缺省情况下，值为 ``'django.views.defaults.server_error'`` 。缺省值一般够用了。

.. versionchanged:: 1.2
    以前版本的 Django 只接受代表路径的字符串。

include
-------

.. function:: include(<module or pattern_list>)

一个包含另一个 URLconf 模式的完整 Python 导入路径的函数。

:func:`include` 也可以用作一个返回 URL 模式的参数。

参见下文 `包括其他 URLconf`_ 。

捕获 URL 中的文本的注意点
===============================

不管哪种正则表达式，在 URL 中捕获的参数都会作为纯 Python 字符串传递给视图。
例如::

    (r'^articles/(?P<year>\d{4})/$', 'news.views.year_archive'),

...传递给 ``news.views.year_archive()`` 的 ``year`` 参数将会是一个字符串，而
不是一个整数。即使 ``\d{4}`` 只匹配整数字符串，传递的参数也只会是一个字符串。

为视图参数定义缺省值有一个小技巧，请看下面的示例 URLconf 和视图::

    # URLconf
    urlpatterns = patterns('',
        (r'^blog/$', 'blog.views.page'),
        (r'^blog/page(?P<num>\d+)/$', 'blog.views.page'),
    )

    # View (in blog/views.py)
    def page(request, num="1"):
        # 根据 num 输出恰当的博客页面。

在上面的例子中，两个 URL 模式都指向同一个视图 ``blog.views.page`` 。但是第一个
模式不捕获 URL 中的任何东西。如果匹配到第一个模式，那么 ``page()`` 函数会使用
缺省的 ``num`` 参数—— ``"1"`` 。如果匹配到第二个模式，那么 ``page()`` 会使用
通过正则表达式捕获的 ``num`` 值。

性能
===========

第个 ``urlpatterns`` 中的正则表达式在第一次调用时都会被编译，因此系统运行速度
非常快。

视图前缀
===============

你可以在 ``patterns()`` 中指定一个公用前缀，以减少代码的重复。

以下是一个 :doc:`Django 概述</intro/overview>` 中的示例 URLconf:: 

    from django.conf.urls.defaults import *

    urlpatterns = patterns('',
        (r'^articles/(\d{4})/$', 'news.views.year_archive'),
        (r'^articles/(\d{4})/(\d{2})/$', 'news.views.month_archive'),
        (r'^articles/(\d{4})/(\d{2})/(\d+)/$', 'news.views.article_detail'),
    )

在这个例子中，每个视图都有一个共同的前缀 ``'news.views'`` 。可以使用
``patterns()`` 的第一个参数来指定一个公用的前缀来代替重复输入。这个前缀会应用到
每一个视图函数。

上例可简化如下::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('news.views',
        (r'^articles/(\d{4})/$', 'year_archive'),
        (r'^articles/(\d{4})/(\d{2})/$', 'month_archive'),
        (r'^articles/(\d{4})/(\d{2})/(\d+)/$', 'article_detail'),
    )

注意前缀后面不要加点（ ``"."`` ）。 Django 会自动为你加上。

Multiple view prefixes
----------------------

In practice, you'll probably end up mixing and matching views to the point
where the views in your ``urlpatterns`` won't have a common prefix. However,
you can still take advantage of the view prefix shortcut to remove duplication.
Just add multiple ``patterns()`` objects together, like this:

Old::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('',
        (r'^$', 'django.views.generic.date_based.archive_index'),
        (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/$', 'django.views.generic.date_based.archive_month'),
        (r'^tag/(?P<tag>\w+)/$', 'weblog.views.tag'),
    )

New::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('django.views.generic.date_based',
        (r'^$', 'archive_index'),
        (r'^(?P<year>\d{4})/(?P<month>[a-z]{3})/$','archive_month'),
    )

    urlpatterns += patterns('weblog.views',
        (r'^tag/(?P<tag>\w+)/$', 'tag'),
    )

包括其他 URLconf
========================

At any point, your ``urlpatterns`` can "include" other URLconf modules. This
essentially "roots" a set of URLs below other ones.

For example, here's the URLconf for the `Django Web site`_ itself. It includes a
number of other URLconfs::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('',
        (r'^weblog/',        include('django_website.apps.blog.urls.blog')),
        (r'^documentation/', include('django_websiThe view prefixte.apps.docs.urls.docs')),
        (r'^comments/',      include('django.contrib.comments.urls')),
    )

Note that the regular expressions in this example don't have a ``$``
(end-of-string match character) but do include a trailing slash. Whenever
Django encounters ``include()``, it chops off whatever part of the URL matched
up to that point and sends the remaining string to the included URLconf for
further processing.

Another possibility is to include additional URL patterns not by specifying the
URLconf Python module defining them as the `include`_ argument but by using
directly the pattern list as returned by `patterns`_ instead. For example::

    from django.conf.urls.defaults import *

    extra_patterns = patterns('',
        url(r'reports/(?P<id>\d+)/$', 'credit.views.report', name='credit-reports'),
        url(r'charge/$', 'credit.views.charge', name='credit-charge'),
    )

    urlpatterns = patterns('',
        url(r'^$',    'apps.main.views.homepage', name='site-homepage'),
        (r'^help/',   include('apps.help.urls')),
        (r'^credit/', include(extra_patterns)),
    )

This approach can be seen in use when you deploy an instance of the Django
Admin application. The Django Admin is deployed as instances of a
:class:`~django.contrib.admin.AdminSite`; each
:class:`~django.contrib.admin.AdminSite` instance has an attribute ``urls``
that returns the url patterns available to that instance. It is this attribute
that you ``include()`` into your projects ``urlpatterns`` when you deploy the
admin instance.

.. _`Django Web site`: http://www.djangoproject.com/

Captured parameters
-------------------

An included URLconf receives any captured parameters from parent URLconfs, so
the following example is valid::

    # In settings/urls/main.py
    urlpatterns = patterns('',
        (r'^(?P<username>\w+)/blog/', include('foo.urls.blog')),
    )

    # In foo/urls/blog.py
    urlpatterns = patterns('foo.views',
        (r'^$', 'blog.index'),
        (r'^archive/$', 'blog.archive'),
    )

In the above example, the captured ``"username"`` variable is passed to the
included URLconf, as expected.

.. _topics-http-defining-url-namespaces:

Defining URL namespaces
-----------------------

When you need to deploy multiple instances of a single application, it can be
helpful to be able to differentiate between instances. This is especially
important when using :ref:`named URL patterns <naming-url-patterns>`, since
multiple instances of a single application will share named URLs. Namespaces
provide a way to tell these named URLs apart.

A URL namespace comes in two parts, both of which are strings:

    * An **application namespace**. This describes the name of the application
      that is being deployed. Every instance of a single application will have
      the same application namespace. For example, Django's admin application
      has the somewhat predictable application namespace of ``admin``.

    * An **instance namespace**. This identifies a specific instance of an
      application. Instance namespaces should be unique across your entire
      project. However, an instance namespace can be the same as the
      application namespace. This is used to specify a default instance of an
      application. For example, the default Django Admin instance has an
      instance namespace of ``admin``.

URL Namespaces can be specified in two ways.

Firstly, you can provide the application and instance namespace as arguments
to ``include()`` when you construct your URL patterns. For example,::

    (r'^help/', include('apps.help.urls', namespace='foo', app_name='bar')),

This will include the URLs defined in ``apps.help.urls`` into the application
namespace ``bar``, with the instance namespace ``foo``.

Secondly, you can include an object that contains embedded namespace data. If
you ``include()`` a ``patterns`` object, that object will be added to the
global namespace. However, you can also ``include()`` an object that contains
a 3-tuple containing::

    (<patterns object>, <application namespace>, <instance namespace>)

This will include the nominated URL patterns into the given application and
instance namespace. For example, the ``urls`` attribute of Django's
:class:`~django.contrib.admin.AdminSite` object returns a 3-tuple that contains
all the patterns in an admin site, plus the name of the admin instance, and the
application namespace ``admin``.

Once you have defined namespaced URLs, you can reverse them. For details on
reversing namespaced urls, see the documentation on :ref:`reversing namespaced
URLs <topics-http-reversing-url-namespaces>`.

传递额外参数给视图函数
=======================================

URLconfs have a hook that lets you pass extra arguments to your view functions,
as a Python dictionary.

Any URLconf tuple can have an optional third element, which should be a
dictionary of extra keyword arguments to pass to the view function.

For example::

    urlpatterns = patterns('blog.views',
        (r'^blog/(?P<year>\d{4})/$', 'year_archive', {'foo': 'bar'}),
    )

In this example, for a request to ``/blog/2005/``, Django will call the
``blog.views.year_archive()`` view, passing it these keyword arguments::

    year='2005', foo='bar'

This technique is used in :doc:`generic views </ref/generic-views>` and in the
:doc:`syndication framework </ref/contrib/syndication>` to pass metadata and
options to views.

.. admonition:: Dealing with conflicts

    It's possible to have a URL pattern which captures named keyword arguments,
    and also passes arguments with the same names in its dictionary of extra
    arguments. When this happens, the arguments in the dictionary will be used
    instead of the arguments captured in the URL.

Passing extra options to ``include()``
--------------------------------------

Similarly, you can pass extra options to ``include()``. When you pass extra
options to ``include()``, *each* line in the included URLconf will be passed
the extra options.

For example, these two URLconf sets are functionally identical:

Set one::

    # main.py
    urlpatterns = patterns('',
        (r'^blog/', include('inner'), {'blogid': 3}),
    )

    # inner.py
    urlpatterns = patterns('',
        (r'^archive/$', 'mysite.views.archive'),
        (r'^about/$', 'mysite.views.about'),
    )

Set two::

    # main.py
    urlpatterns = patterns('',
        (r'^blog/', include('inner')),
    )

    # inner.py
    urlpatterns = patterns('',
        (r'^archive/$', 'mysite.views.archive', {'blogid': 3}),
        (r'^about/$', 'mysite.views.about', {'blogid': 3}),
    )

Note that extra options will *always* be passed to *every* line in the included
URLconf, regardless of whether the line's view actually accepts those options
as valid. For this reason, this technique is only useful if you're certain that
every view in the included URLconf accepts the extra options you're passing.

Passing callable objects instead of strings
===========================================

Some developers find it more natural to pass the actual Python function object
rather than a string containing the path to its module. This alternative is
supported -- you can pass any callable object as the view.

For example, given this URLconf in "string" notation::

    urlpatterns = patterns('',
        (r'^archive/$', 'mysite.views.archive'),
        (r'^about/$', 'mysite.views.about'),
        (r'^contact/$', 'mysite.views.contact'),
    )

You can accomplish the same thing by passing objects rather than strings. Just
be sure to import the objects::

    from mysite.views import archive, about, contact

    urlpatterns = patterns('',
        (r'^archive/$', archive),
        (r'^about/$', about),
        (r'^contact/$', contact),
    )

The following example is functionally identical. It's just a bit more compact
because it imports the module that contains the views, rather than importing
each view individually::

    from mysite import views

    urlpatterns = patterns('',
        (r'^archive/$', views.archive),
        (r'^about/$', views.about),
        (r'^contact/$', views.contact),
    )

The style you use is up to you.

Note that if you use this technique -- passing objects rather than strings --
the view prefix (as explained in "视图前缀" above) will have no effect.

.. _naming-url-patterns:

命名 URL 模式
===================

It's fairly common to use the same view function in multiple URL patterns in
your URLconf. For example, these two URL patterns both point to the ``archive``
view::

    urlpatterns = patterns('',
        (r'^archive/(\d{4})/$', archive),
        (r'^archive-summary/(\d{4})/$', archive, {'summary': True}),
    )

This is completely valid, but it leads to problems when you try to do reverse
URL matching (through the ``permalink()`` decorator or the :ttag:`url` template
tag). Continuing this example, if you wanted to retrieve the URL for the
``archive`` view, Django's reverse URL matcher would get confused, because *two*
URLpatterns point at that view.

To solve this problem, Django supports **named URL patterns**. That is, you can
give a name to a URL pattern in order to distinguish it from other patterns
using the same view and parameters. Then, you can use this name in reverse URL
matching.

Here's the above example, rewritten to use named URL patterns::

    urlpatterns = patterns('',
        url(r'^archive/(\d{4})/$', archive, name="full-archive"),
        url(r'^archive-summary/(\d{4})/$', archive, {'summary': True}, "arch-summary"),
    )

With these names in place (``full-archive`` and ``arch-summary``), you can
target each pattern individually by using its name:

.. code-block:: html+django

    {% url arch-summary 1945 %}
    {% url full-archive 2007 %}

Even though both URL patterns refer to the ``archive`` view here, using the
``name`` parameter to ``url()`` allows you to tell them apart in templates.

The string used for the URL name can contain any characters you like. You are
not restricted to valid Python names.

.. note::

    When you name your URL patterns, make sure you use names that are unlikely
    to clash with any other application's choice of names. If you call your URL
    pattern ``comment``, and another application does the same thing, there's
    no guarantee which URL will be inserted into your template when you use
    this name.

    Putting a prefix on your URL names, perhaps derived from the application
    name, will decrease the chances of collision. We recommend something like
    ``myapp-comment`` instead of ``comment``.

.. _topics-http-reversing-url-namespaces:

URL namespaces
--------------

Namespaced URLs are specified using the ``:`` operator. For example, the main
index page of the admin application is referenced using ``admin:index``. This
indicates a namespace of ``admin``, and a named URL of ``index``.

Namespaces can also be nested. The named URL ``foo:bar:whiz`` would look for
a pattern named ``whiz`` in the namespace ``bar`` that is itself defined within
the top-level namespace ``foo``.

When given a namespaced URL (e.g. ``myapp:index``) to resolve, Django splits
the fully qualified name into parts, and then tries the following lookup:

    1. First, Django looks for a matching application namespace (in this
       example, ``myapp``). This will yield a list of instances of that
       application.

    2. If there is a *current* application defined, Django finds and returns
       the URL resolver for that instance. The *current* application can be
       specified as an attribute on the template context - applications that
       expect to have multiple deployments should set the ``current_app``
       attribute on any ``Context`` or ``RequestContext`` that is used to
       render a template.

       The current application can also be specified manually as an argument
       to the :func:`reverse()` function.

    3. If there is no current application. Django looks for a default
       application instance. The default application instance is the instance
       that has an instance namespace matching the application namespace (in
       this example, an instance of the ``myapp`` called ``myapp``).

    4. If there is no default application instance, Django will pick the last
       deployed instance of the application, whatever its instance name may be.

    5. If the provided namespace doesn't match an application namespace in
       step 1, Django will attempt a direct lookup of the namespace as an
       instance namespace.

If there are nested namespaces, these steps are repeated for each part of the
namespace until only the view name is unresolved. The view name will then be
resolved into a URL in the namespace that has been found.

To show this resolution strategy in action, consider an example of two instances
of ``myapp``: one called ``foo``, and one called ``bar``. ``myapp`` has a main
index page with a URL named `index`. Using this setup, the following lookups are
possible:

    * If one of the instances is current - say, if we were rendering a utility page
      in the instance ``bar`` - ``myapp:index`` will resolve to the index page of
      the instance ``bar``.

    * If there is no current instance - say, if we were rendering a page
      somewhere else on the site - ``myapp:index`` will resolve to the last
      registered instance of ``myapp``. Since there is no default instance,
      the last instance of ``myapp`` that is registered will be used. This could
      be ``foo`` or ``bar``, depending on the order they are introduced into the
      urlpatterns of the project.

    * ``foo:index`` will always resolve to the index page of the instance ``foo``.

If there was also a default instance - i.e., an instance named `myapp` - the
following would happen:

    * If one of the instances is current - say, if we were rendering a utility page
      in the instance ``bar`` - ``myapp:index`` will resolve to the index page of
      the instance ``bar``.

    * If there is no current instance - say, if we were rendering a page somewhere
      else on the site - ``myapp:index`` will resolve to the index page of the
      default instance.

    * ``foo:index`` will again resolve to the index page of the instance ``foo``.


Utility methods
===============

.. currentmodule:: django.core.urlresolvers

reverse()
---------

If you need to use something similar to the :ttag:`url` template tag in
your code, Django provides the following method (in the
``django.core.urlresolvers`` module):

.. function:: reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None)

``viewname`` is either the function name (either a function reference, or the
string version of the name, if you used that form in ``urlpatterns``) or the
`URL pattern name`_.  Normally, you won't need to worry about the
``urlconf`` parameter and will only pass in the positional and keyword
arguments to use in the URL matching. For example::

    from django.core.urlresolvers import reverse

    def myview(request):
        return HttpResponseRedirect(reverse('arch-summary', args=[1945]))

.. _URL pattern name: `命名 URL 模式`_

The ``reverse()`` function can reverse a large variety of regular expression
patterns for URLs, but not every possible one. The main restriction at the
moment is that the pattern cannot contain alternative choices using the
vertical bar (``"|"``) character. You can quite happily use such patterns for
matching against incoming URLs and sending them off to views, but you cannot
reverse such patterns.

The ``current_app`` argument allows you to provide a hint to the resolver
indicating the application to which the currently executing view belongs.
This ``current_app`` argument is used as a hint to resolve application
namespaces into URLs on specific application instances, according to the
:ref:`namespaced URL resolution strategy <topics-http-reversing-url-namespaces>`.

.. admonition:: Make sure your views are all correct.

    As part of working out which URL names map to which patterns, the
    ``reverse()`` function has to import all of your URLconf files and examine
    the name of each view. This involves importing each view function. If
    there are *any* errors whilst importing any of your view functions, it
    will cause ``reverse()`` to raise an error, even if that view function is
    not the one you are trying to reverse.

    Make sure that any views you reference in your URLconf files exist and can
    be imported correctly. Do not include lines that reference views you
    haven't written yet, because those views will not be importable.

resolve()
---------

The :func:`django.core.urlresolvers.resolve` function can be used for
resolving URL paths to the corresponding view functions. It has the
following signature:

.. function:: resolve(path, urlconf=None)

``path`` is the URL path you want to resolve. As with
:func:`~django.core.urlresolvers.reverse`, you don't need to
worry about the ``urlconf`` parameter. The function returns a
:class:`ResolverMatch` object that allows you
to access various meta-data about the resolved URL.

If the URL does not resolve, the function raises an
:class:`~django.http.Http404` exception.

.. class:: ResolverMatch

    .. attribute:: ResolverMatch.func

        The view function that would be used to serve the URL

    .. attribute:: ResolverMatch.args

        The arguments that would be passed to the view function, as
        parsed from the URL.

    .. attribute:: ResolverMatch.kwargs

        The keyword arguments that would be passed to the view
        function, as parsed from the URL.

    .. attribute:: ResolverMatch.url_name

        The name of the URL pattern that matches the URL.

    .. attribute:: ResolverMatch.app_name

        The application namespace for the URL pattern that matches the
        URL.

    .. attribute:: ResolverMatch.namespace

        The instance namespace for the URL pattern that matches the
        URL.

    .. attribute:: ResolverMatch.namespaces

        The list of individual namespace components in the full
        instance namespace for the URL pattern that matches the URL.
        i.e., if the namespace is ``foo:bar``, then namespaces will be
        ``['foo', 'bar']``.

A :class:`ResolverMatch` object can then be interrogated to provide
information about the URL pattern that matches a URL::

    # Resolve a URL
    match = resolve('/some/path/')
    # Print the URL pattern that matches the URL
    print match.url_name

A :class:`ResolverMatch` object can also be assigned to a triple::

    func, args, kwargs = resolve('/some/path/')

.. versionchanged:: 1.3
    Triple-assignment exists for backwards-compatibility. Prior to
    Django 1.3, :func:`~django.core.urlresolvers.resolve` returned a
    triple containing (view function, arguments, keyword arguments);
    the :class:`ResolverMatch` object (as well as the namespace and pattern
    information it provides) is not available in earlier Django releases.

One possible use of :func:`~django.core.urlresolvers.resolve` would be
to testing if a view would raise a ``Http404`` error before
redirecting to it::

    from urlparse import urlparse
    from django.core.urlresolvers import resolve
    from django.http import HttpResponseRedirect, Http404

    def myview(request):
        next = request.META.get('HTTP_REFERER', None) or '/'
        response = HttpResponseRedirect(next)

        # modify the request and response as required, e.g. change locale
        # and set corresponding locale cookie

        view, args, kwargs = resolve(urlparse(next)[2])
        kwargs['request'] = request
        try:
            view(*args, **kwargs)
        except Http404:
            return HttpResponseRedirect('/')
        return response


permalink()
-----------

The :func:`django.db.models.permalink` decorator is useful for writing short
methods that return a full URL path. For example, a model's
``get_absolute_url()`` method. See :func:`django.db.models.permalink` for more.

get_script_prefix()
-------------------

.. function:: get_script_prefix()

Normally, you should always use :func:`~django.core.urlresolvers.reverse` or
:func:`~django.db.models.permalink` to define URLs within your application.
However, if your application constructs part of the URL hierarchy itself, you
may occasionally need to generate URLs. In that case, you need to be able to
find the base URL of the Django project within its Web server
(normally, :func:`~django.core.urlresolvers.reverse` takes care of this for
you). In that case, you can call ``get_script_prefix()``, which will return the
script prefix portion of the URL for your Django project. If your Django
project is at the root of its Web server, this is always ``"/"``, but it can be
changed, for instance  by using ``django.root`` (see :doc:`How to use
Django with Apache and mod_python </howto/deployment/modpython>`).
